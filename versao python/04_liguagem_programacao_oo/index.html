<!DOCTYPE html>
<html lang="pt-br" xmlns:mso="urn:schemas-microsoft-com:office:office"
  xmlns:msdt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>Linguagem de programação orientada a objetos: sintaxe da linguagem para orientação a objeto, definição de classes, atributos, encapsulamentos, métodos, herança, interface, polimorfismo e modificadores de acesso.</title>

  <!-- Bootstrap -->
  <link href="../template/css/bootstrap.min.css" rel="stylesheet">
  <link href="../template/css/tecnicos_senac.css" rel="stylesheet">
  <link href="../template/css/cores.css" rel="stylesheet">
  <!--Extras - novas classes para facilitar-->
  <link rel="stylesheet" href="../template/css/extras.css">
  <link href="../template/css/sncload.css" rel="stylesheet">
  <link href="../template/css/magnific-popup.css" rel="stylesheet">
  <!-- referencia ao arquivo css com estilos especificos da pagina -->
  <link href="css/custom.css" type="text/css" rel="stylesheet">
  <!-- css necessario para o print -->
  <link href="../template/css/fa/css/font-awesome.min.css" type="text/css" rel="stylesheet">
  <link href="../template/css/print.css" type="text/css" rel="stylesheet">
  <link href="../template/fonts/roboto.css" type="text/css" rel="stylesheet">

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
      <script src="js/respond.min.js"></script>
    <![endif]-->


  <!--[if gte mso 9]><xml>
<mso:CustomDocumentProperties>
<mso:display_urn_x003a_schemas-microsoft-com_x003a_office_x003a_office_x0023_Editor msdt:dt="string">Paulo Ricardo Soveral Junior</mso:display_urn_x003a_schemas-microsoft-com_x003a_office_x003a_office_x0023_Editor>
<mso:Order msdt:dt="string">46914400.0000000</mso:Order>
<mso:display_urn_x003a_schemas-microsoft-com_x003a_office_x003a_office_x0023_Author msdt:dt="string">Paulo Ricardo Soveral Junior</mso:display_urn_x003a_schemas-microsoft-com_x003a_office_x003a_office_x0023_Author>
<mso:ContentTypeId msdt:dt="string">0x010100393332CEE5C5294F9D2C3CF7CCDACBE5</mso:ContentTypeId>
</mso:CustomDocumentProperties>
</xml><![endif]-->
</head>

<body onLoad="Javascript:document.getElementById('sncloader').style.display='none';">
  <!-- MARCA D´ÁGUA -->
  <img src="../template/images/logo_senac_colorido.png" id="marcadaguaLogo">
  <!-- /MARCA D´ÁGUA -->

  <div id='sncloader' class='over-loader'>
    <div class="over-cell">
      <div id="sncload"></div>
    </div>
  </div>
  <header id="topo" class="senac no-print">
    <div class="header-tecnicos container">
      <h1 id="nome-curso">Desenvolvimento de Sistemas</h1>
      <div id="logo-senac"><img src="../template/images/logo-senac.png" alt="logo do senac"></div>
    </div>
    <div id="sombra"></div>
  </header>

  <div id="booklet" class="container fundo-tecnicos">

    <div class="acessivel no-print">
      <p>Como sugestão, configure a opção de leitura de caracteres e de pontuação de seu leitor de tela para o grau
        máximo de leitura, a fim de que os códigos disponibilizados neste material sejam lidos corretamente. No caso do
        NVDA (Nonvisual Desktop Access), para localizar a opção <b>Grau de pontuação/símbolos, acesse Preferências –
          Configurações – Fala</b>. Altere o padrão <b>Pouco</b> para <b>Tudo</b>. Dessa forma, o leitor passará a ler
        os segmentos de código em sua totalidade.</p>
    </div>

    <header class="no-print">
      <!-- BTO IMPRIMIR -->
      <div class="grupo-imprimir no-print">
        <button type="button" data-pdf="true" class="bto-imprimir" name="button">
          <span class="fa fa-print"></span> <span>Imprimir</span>
        </button>
      </div>
      <!-- /BTO IMPRIMIR -->
    </header>
    <!-- - - - - - - - - - - - - - - - não alterar acima - - - - - - - - - - - - -->
    <section class="paginas">

      <!-- - - - - - - - cada página é independente  - - - - - - - - - - -->
      <div class="pagina pag-principal no-print">
        <h2 class="text-center mt-40">Linguagem de programação orientada a objetos: sintaxe da linguagem para orientação a objeto, definição de classes, atributos, encapsulamentos, métodos, herança, interface, polimorfismo e modificadores de acesso.</h2>

        <p class="text-center mt-40" aria-hidden="true">Clique ou toque para visualizar o conteúdo.</p>

        <div class="menu-piramide hidden-xs">
          <a href="index.html?page=2" id="menu-titulo1" class="menu-titulo menu-titulo1" target="_blank"></a>
          <a href="index.html?page=3" id="menu-titulo2" class="menu-titulo menu-titulo2" target="_blank"></a>
          <a href="index.html?page=4" id="menu-titulo3" class="menu-titulo menu-titulo3" target="_blank"></a>
          <a href="index.html?page=5" id="menu-titulo4" class="menu-titulo menu-titulo4" target="_blank"></a>
          <a href="index.html?page=6" id="menu-titulo5" class="menu-titulo menu-titulo5" target="_blank"></a>
          <a href="index.html?page=7" id="menu-titulo6" class="menu-titulo menu-titulo6" target="_blank"></a>
          <a href="index.html?page=8" id="menu-titulo7" class="menu-titulo menu-titulo7" target="_blank"></a>
          <a href="index.html?page=9" id="menu-titulo8" class="menu-titulo menu-titulo8" target="_blank"></a>
        </div>

        <div class="menu-piramide_mobile visible-xs">
          <a href="index.html?page=2" id="menu-titulo1_mobile" class="menu-titulo_mobile" target="_blank"></a>
          <a href="index.html?page=3" id="menu-titulo2_mobile" class="menu-titulo_mobile" target="_blank"></a>
          <a href="index.html?page=4" id="menu-titulo3_mobile" class="menu-titulo_mobile" target="_blank"></a>
          <a href="index.html?page=5" id="menu-titulo4_mobile" class="menu-titulo_mobile" target="_blank"></a>
          <a href="index.html?page=6" id="menu-titulo5_mobile" class="menu-titulo_mobile" target="_blank"></a>
          <a href="index.html?page=7" id="menu-titulo6_mobile" class="menu-titulo_mobile" target="_blank"></a>
          <a href="index.html?page=8" id="menu-titulo7_mobile" class="menu-titulo_mobile" target="_blank"></a>
          <a href="index.html?page=9" id="menu-titulo8_mobile" class="menu-titulo_mobile" target="_blank"></a>
        </div>

      </div>

      <!-- Página 2 -->
      <div class="pagina">
        <h3>Introdução</h3>
        <p>Como você já deve ter aprendido, diversos conceitos da programação fazem abstrações e comparações com o mundo
          real. Por exemplo, os conceitos de estrutura de dados contêm diversos paralelos com a vida real, como uma fila
          de pessoas, uma pilha de roupas etc. Isso acontece porque diariamente tenta-se resolver problemas reais e a
          melhor forma de alcançar esse objetivo é abstraindo conceitos reais para dentro do código-fonte.</p>
        <p>Com a programação orientada a objetos não é diferente. No decorrer dos anos, foram criados conceitos que
          abstraem e relacionam a estruturação de um <i>software</i> com o mundo real. Esses conceitos visam a
          estruturar de maneira organizada o código-fonte, separando responsabilidades e simplificando o código.</p>
        <p>Conheça agora alguns desses conceitos e entenda o seu uso e, mais importante, quando utilizá-los.</p>

        <h3>Herança</h3>
        <img src="objetos/layout_5_fig1.jpg" class="img-responsive center-block">
        <p class="legenda-imagem">
          A herança está no próprio ser humano, em seus genes <br>
          Fonte: Andrade (2013)
        </p>
        <p class="acessivel no-print">A imagem mostra a representação da evolução da espécie humana a partir de primatas
          com seis figuras, sendo a primeira de um macaco e a última de um homem.</p>
        <p>O conceito de herança é muito comum na vida. A evolução das espécies, as características semelhantes entre
          uma criança e seus pais são apenas alguns dos diversos exemplos práticos de herança.</p>

        <div class="caixa-destaque icone importante">
          <p>Na programação orientada a objetos, o conceito de herança é utilizado para que uma classe herde os
            comportamentos e as características de outra classe diferente.</p>
        </div>

        <p>Para facilitar a compreensão dos próximos tópicos, pense na relação do conceito de herança com o verbo
          <b>ser</b>. Por exemplo, se houver uma classe chamada <b>Pessoa</b> e uma classe chamada <b>Aluno</b>,
          relacionadas por meio do conceito de herança, será possível afirmar que um “aluno” <b>é</b> uma “pessoa”.</p>
        <p>Quando se aplica o conceito de herança na programação orientada a objetos, cria-se uma relação de mãe e
          filha. A classe filha herda as características da classe mãe. Uma classe mãe é chamada de <b>superclasse</b>
          ou <b>classe-base</b>. Já uma classe filha é chamada de <b>subclasse</b> ou <b>classe derivada</b>.</p>
        <p>Uma subclasse herda todos os métodos e atributos públicos (<i>public</i>) ou protegidos (<i>protected</i>) de
          sua superclasse, podendo sobrescrevê-los para alterar o comportamento. Já os métodos privados (<i>private</i>)
          da superclasse não são visíveis para a subclasse.</p>

        <p>Para compreender melhor, observe o diagrama a seguir e também os <i>gifs</i> retirados dos <i>sites</i> Gifer
          (s.d.).</p>
        <div class="no-print" aria-hidden="true">
          <p>Clique ou toque para visualizar o conteúdo.</p>
          <div class="div-painel_robo">
            <button type="button" class="btn-painel_robo btn-painel_robo01 center-block" data-toggle="modal" data-target="#modal-painel_robo01"></button>
            <button type="button" class="btn-painel_robo btn-painel_robo02 center-block" data-toggle="modal" data-target="#modal-painel_robo02"></button>
            <button type="button" class="btn-painel_robo btn-painel_robo03 center-block" data-toggle="modal" data-target="#modal-painel_robo03"></button>
          </div>
          <!-- <p class="legenda-imagem">
            Herança de uma classe robô (mais genérica) e classes que são derivadas dela <br>
            Fonte: Senac EAD (2022)
          </p>
          <p class="acessivel no-print">A imagem mostra um diagrama UML com classe “Robô”, atributos “Bateria” e
            “Fabricante”, métodos “Movimentar()” e “EvitarObstaculos()”. Abaixo, à esquerda, aparece a classe derivada
            “Robô Cheetah”, com método “Pular()”. Abaixo da classe “Robô”, à direita, está a classe derivada “Robô de
            Limpeza”, com atributo “HoraAgendada” e médodo “Aspirar()”.</p> -->
        </div>
        <div class="acessivel print">
          <img src='objetos/layout_5_fig2.png' class='img-responsive center-block'>
          <!-- <p class="legenda-imagem">
            Herança de uma classe robô (mais genérica) e classes que são derivadas dela <br>
            Fonte: Senac EAD (2022)
          </p>
          <p class="acessivel no-print">A imagem mostra um diagrama UML com classe “Robô”, atributos “Bateria” e
            “Fabricante”, métodos “Movimentar()” e “EvitarObstaculos()”. Abaixo, à esquerda, aparece a classe derivada
            “Robô Cheetah”, com método “Pular()”. Abaixo da classe “Robô”, à direita, está a classe derivada “Robô de
            Limpeza”, com atributo “HoraAgendada” e médodo “Aspirar()”.</p> -->
          <img src='objetos/gif_01.gif' class='img-responsive center-block'>
          <p class="acessivel no-print">A animação mostra um robô quadrúpede pulando um obstáculo.</p>
          <img src='objetos/gif_02.gif' class='img-responsive center-block'>
          <p class="acessivel no-print">A animação mostra um robô comum de limpeza percorrendo um corredor e mudando sua
            direção ao encontrar as paredes.</p>
        </div>
        <p>Os <i>gifs</i> mostraram o robô Cheetah, que, além das capacidades normais de robô, ainda pode pular, e o
          robô de limpeza, que, além de movimentar e evitar obstáculos, aspira e tem um agendamento para iniciar a
          limpeza. Nesse exemplo, <b>Robô</b> é classe mãe, <b>Robô Cheetah</b> e <b>Robô Limpeza</b> são classes filhas
          ou derivadas.</p>
        
        <!--OBJETO 3-->
        <a href="objeto/index.html" target="_blank" class="btn-objeto_3"></a>

        <p>Neste momento, será criada a estrutura exemplificada anteriormente, de <b>Pessoas</b> e <b>Alunos</b>,
          utilizando o conceito de herança da programação orientada a objetos. Analise este código:</p>

        <pre>
          <code class="language-phyton">
<span class="l-python-orange">import</span> uuid 
 
<span class="l-python-orange">class</span> Pessoa: 
    <span class="l-python-orange">def</span> <span class="l-python-violeta">__init__</span>(<span class="l-python-violeta">self</span>): 
       <span class="l-python-violeta"> self</span>.__nome = <span class="l-python-green">""</span> 
       <span class="l-python-violeta"> self</span>.__cpf = <span class="l-python-green">""</span> 
       <span class="l-python-violeta"> self</span>.__uuid = uuid.uuid4() 
                            
    <span class="l-python-orange">def</span> <span class="l-python-blue">set_nome</span>(<span class="l-python-violeta">self</span>, nome): 
        <span class="l-python-violeta">self</span>.__nome = nome 
                             
    <span class="l-python-orange">def</span> <span class="l-python-blue">get_nome</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.__nome 
                             
    <span class="l-python-orange">def</span> <span class="l-python-blue">set_cpf</span>(<span class="l-python-violeta">self</span>, cpf): 
        <span class="l-python-violeta">self</span>.__cpf = cpf 
                             
    <span class="l-python-orange">def</span> <span class="l-python-blue">get_cpf</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.__cpf 
                             
   <span class="l-python-orange"> def</span> <span class="l-python-blue">apresentar</span>(<span class="l-python-violeta">self</span>): 
       <span class="l-python-aescuro"> print</span>(<span class="l-python-green">f"Nome:</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.get_nome()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
       <span class="l-python-aescuro"> print</span>(<span class="l-python-green">f"CPF:</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.get_cpf()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
       <span class="l-python-aescuro"> print</span>(<span class="l-python-green">f"UUID:</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.__uuid<span class="l-python-orange">}</span><span class="l-python-green">"</span>)

# Criando um objeto da classe Pessoa 
pessoa = Pessoa() 
         
# Definindo valores para os atributos usando os métodos set 
pessoa.set_nome(<span class="l-python-green">"Alice"</span>) 
pessoa.set_cpf(<span class="l-python-green">"123.456.789-00"</span>) 
         
# Apresentando os dados da pessoa usando os métodos get 
pessoa.apresentar() 
        
    <!-- <span class="l-python-orange">def</span> <span class="l-python-blue">set_nome</span>(<span class="l-python-violeta">self</span>, nome): 
        <span class="l-python-violeta">self</span>.__nome = nome 
         
    <span class="l-python-orange">def</span> <span class="l-python-blue">get_nome</span>(self): 
        <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.__nome 
         
   <span class="l-python-orange">def</span> <span class="l-python-blue">set_cpf</span>(<span class="l-python-violeta">self</span>, cpf): 
        <span class="l-python-violeta">self</span>.__cpf = cpf 
         
    <span class="l-python-orange">def</span> <span class="l-python-blue">get_cpf</span>(self): 
       <span class="l-python-orange"> return</span> <span class="l-python-violeta">self</span>.__cpf 
         
    <span class="l-python-orange">def</span> <span class="l-python-blue">apresentar</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Nome:</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.get_nome()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"CPF:</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.get_cpf()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"UUID:</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.__uuid<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
         
# Criando um objeto da classe Pessoa 
pessoa = Pessoa() 
         
# Definindo valores para os atributos usando os métodos set 
pessoa.set_nome(<span class="l-python-green">"Alice"</span>) 
pessoa.set_cpf(<span class="l-python-green">"123.456.789-00"</span>) 
         
# Apresentando os dados da pessoa usando os métodos get 
pessoa.apresentar()  -->
            </code>
        </pre>
       <p>
          Nessa classe, o construtor __init__ cria um objeto UUID usando a biblioteca UUID para gerar
          um
          identificador único. Os atributos nome e cpf são inicializados como <i>strings</i> vazias,
          mas
          você
          pode
          atribuir valores a eles conforme necessário.
        </p>
        <p>
          Esse exemplo ilustra como criar um objeto da classe Pessoa para criar objeto sem fornecer
          parâmetros
          para o construtor e, em seguida, definir os valores dos atributos posteriormente.
        </p>

        <div class="caixa-destaque icone importante">
          <p>
              UUID (<i>Universally Unique Identifier</i>) é um identificador único universal, também
              conhecido
              como
              GUID (<i>Globally Unique Identifier</i>). É uma sequência de caracteres usada para
              identificar
              exclusivamente uma entidade, seja um objeto, um documento, um recurso ou qualquer outra
              coisa,
              em um sistema distribuído.
          </p>

          <p>
              As UUIDs são amplamente utilizadas em sistemas de computação para garantir que os
              identificadores sejam únicos em ambientes distribuídos e evitem conflitos de
              identificação.
              Elas
              são especialmente úteis quando várias entidades precisam ser identificadas de forma
              exclusiva,
              sem depender de uma autoridade central para gerar os identificadores. Uma UUID é
              geralmente
              representada como uma sequência de 36 caracteres hexadecimal, como esta:
          </p>
          <pre>
              <code>
  550e8400-e29b-41d4-a716-446655440000  
              </code>
          </pre>
          <p>
              Existem diferentes versões e variantes de UUIDs, cada uma com suas próprias regras para
              geração.
              Uma das versões mais comuns é a UUID-4, que é gerada aleatoriamente usando informações
              do
              sistema, como endereço MAC e <i>timestamp</i>. Isso a torna altamente improvável de ser
              duplicada,
              mesmo em sistemas distribuídos.
          </p>
          <p>
              As UUIDs são amplamente utilizadas em várias aplicações, como bancos de dados, sistemas
              de
              rastreamento, identificação de recursos na web e muitos outros contextos em que a
              garantia
              de
              unicidade é essencial.
          </p>
        </div>

        <p>
          No exemplo, os atributos __nome, __cpf e __uuid são privados. Para acessar ou modificar
          esses
          atributos, você deve usar métodos de acesso (<i>getters</i> e <i>setters</i>), como
          set_nome,
          get_nome, set_cpf e
          get_cpf. A convenção de nomenclatura com um sublinhado duplo indica que esses atributos
          devem
          ser
          considerados privados. É uma prática comum em Python para encapsular o acesso aos atributos
          de
          uma
          classe.
        </p>
       
        <div class="caixa-destaque icone anotar">
          <p> Nota<sub>1</sub></p>
          <p>
              Para os exemplos deste conteúdo, crie um projeto PyCharm, implemente as classes e
              programe o
              método main() da classe principal quando necessário. Se necessário, crie um projeto para
              cada
              exemplo ou um para cada subtítulo, para organizar seus estudos.
          </p>
          <p> Nota<sub>2</sub></p>
          <p>
              O PyCharm é um ambiente de desenvolvimento integrado (IDE) para a linguagem de
              programação
              Python. Ele fornece uma variedade de recursos para ajudar os desenvolvedores a escrever,
              depurar, testar e implantar o código Python.
          </p>
        </div>

        <p>
            Assista ao vídeo a seguir para compreender o passo a passo de criação de um projeto Python no Pycharm.
        </p>
        <div class="video-1">VIDEO</div>
                   
        <div class="acessivel print">
            <h3>O que é criar um projeto Python no PyCharm? </h3>
            <p>
                Criar um projeto Python no PyCharm é o processo de criar uma estrutura de arquivos e
                pastas
                que
                contenham seu código-fonte Python. Isso permite que você organize seu código e o faça
                mais
                fácil
                de
                gerenciar.
            </p>
            <p>Para criar um projeto Python no PyCharm, siga estas etapas: </p>
            <ol>
                <li>Abra o PyCharm. </li>
                <li>No menu principal, selecione File > New > Project. </li>
                <li>Na janela Create New Project, selecione Python na lista de Languages. </li>
                <li>Na seção Project Name, insira um nome para o seu projeto. </li>
                <li>Na seção Project Location, selecione o local onde deseja salvar o projeto. </li>
                <li>Na seção Project SDK, selecione a versão do Python que deseja usar. </li>
                <li>Clique em Create. </li>
            </ol>
            <p>
                O PyCharm criará uma estrutura de arquivos e pastas para o seu projeto. O arquivo
                principal
                do seu
                projeto será chamado “main.py”.
            </p>
            <p>
                Veja alguns recursos do PyCharm que podem ser úteis para desenvolver projetos Python:
            </p>
            <ul>
                <li>IntelliSense: o IntelliSense fornece sugestões de código enquanto você digita. </li>
                <li>Depuração: o PyCharm permite depurar seu código para encontrar e corrigir erros.
                </li>
                <li>Testes: o PyCharm fornece ferramentas para escrever e executar testes para seu
                    código.
                </li>
                <li>Implantação: o PyCharm pode ajudá-lo a implantar seu código em um servidor ou
                    ambiente
                    de nuvem. </li>
            </ul>
            <p>Para saber mais sobre o PyCharm, consulte a documentação oficial. </p>
        </div>

        <p>Agora, crie a classe <b>Aluno</b>. Essa classe será uma subclasse da classe <b>Pessoa</b>, herdando todos os
          seus métodos e atributos públicos ou protegidos. Confira o código a seguir:</p>

        <pre>
            <code>
    <span class="l-python-orange">class</span> Aluno(Pessoa): 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>() 
        <span class="l-python-violeta">self</span>.__matricula = <span class="l-python-green">""</span> 

        <span class="l-python-orange">def</span> <span class="l-python-blue">set_matricula</span>(<span class="l-python-violeta">self</span>, matricula): 
        <span class="l-python-violeta">self</span>.__matricula = matricula 

        <span class="l-python-orange">def</span> <span class="l-python-blue">get_matricula</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.__matricula 

        <span class="l-python-orange">def</span> <span class="l-python-blue">apresentar</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">super</span>().apresentar() 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Matrícula:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.get_matricula()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
             
# Criando um objeto da classe Aluno 
aluno = Aluno() 
             
# Definindo valores para os atributos da classe Pessoa usando os métodos set 
aluno.set_nome(<span class="l-python-green">"Maria"</span>) 
aluno.set_cpf(<span class="l-python-green">"987.654.321-00"</span>) 
             
# Definindo um valor específico para o atributo da classe Aluno usando o método set 
aluno.set_matricula(<span class="l-python-green">"12345"</span>) 
             
# Apresentando os dados do aluno usando os métodos get 
aluno.apresentar() 
            </code>
        </pre>
        
        <p>
          Nesse exemplo, a classe “Aluno” herda da classe “Pessoa” usando a palavra-chave class
          Aluno(Pessoa):. O construtor da classe “Aluno” (__init__) usa super().__init__() para chamar
          o
          construtor da classe “Pessoa” e, em seguida, define o atributo matrícula específico da
          classe
          “Aluno”.
        </p>
        
        <div class="caixa-destaque icone importante">
          <p>
              Python <b>não</b> usa a palavra-chave “extends” para indicar herança, como algumas
              outras
              linguagens de programação, como Python. Em Python, a herança é indicada usando a
              classe-base
              diretamente na definição da classe derivada.
          </p>
          <p> Em Python, você usa a seguinte sintaxe para criar uma subclasse (classe):
          </p>
          <pre>
          <code>
class ClasseBase: 
# Definição da classe base 
           
class Subclasse(ClasseBase): 
# Definição da subclasse que herda de ClasseBase 
          </code>
         </pre>
          <p>Nesse exemplo, a subclasse herda de ClasseBase. Você não precisa das palavras-chave
              “extends”
              ou “inherit”, como em algumas outras linguagens de programação.
          </p>
        </div>
        
        <div class="caixa-destaque-livre bg-primaria-02 borda-primaria-03">
          <p><b>Exemplo 1</b>: implementando classes para representar funcionários de uma empresa, os quais têm nome e
            salário. Os funcionários podem ser vendedores, que também têm comissão, ou administrativos, aos quais é
            necessário indicar seu o cargo. A todos os funcionários é possível aplicar aumento. O seguinte diagrama UML
            representa as classes <b>Vendedor</b> e <b>Administrativo</b> separadamente.</p>
          <img src="objetos/layout_5_fig3.png" class="img-responsive center-block">
          <p class="legenda-imagem">
            Classes <b>Vendedor</b> e <b>Administrativo</b> <br>
            Fonte: Senac EAD (2024)
          </p>
          <p class="acessivel no-print">A imagem mostra um diagrama para a classe “Vendedor”, com os atributos “nome:
            String”, “salario: float” e “comissão: float” e o método “aplicaAumento(float v)”. À direita, há uma
            diagrama para classe “Administrativo”, com os atributos “nome: String”, “salario: float”, “cargo: String” e
            o método “aplicaAumento(float v)”.</p>
        </div>


        <p>Pelo diagrama, nota-se a repetição nos atributos “nome” e “salário”, além do método <b>aplicaAumento()</b>.
          Isso e o contexto apresentado mostram indícios de que uma hierarquia de classes pode ser importante:</p>
        <img src="objetos/layout_5_fig4.png" class="img-responsive center-block">
        <p class="legenda-imagem">
          Diagrama adaptado com hierarquia de classes (<b>Vendedor</b> e <b>Administrativo</b> derivam de
          <b>Funcionario</b>) <br>
          Fonte: Senac EAD (2024)
        </p>

        <p class="acessivel no-print">Diagrama para classe “Funcionario” com os atributos “nome: String” e “salario:
          float” e o método “aplicaAumento(float v)”. Ligada por flecha de hierarquia à esquerda está a classe
          “Vendedor”, com “comissão: float”. Ligada à classe “Funcionario” por flecha de hierarquia à direita está um
          diagrama para a classe “Administrativo”, com o atributo “cargo: String”.</p>


        <p>
          Exemplo em Python de classes que representam funcionários de uma empresa, incluindo
          vendedores e
          funcionários administrativos. A hierarquia de classes ajudará a evitar a repetição de
          código.
          Veja o código comentado:
        </p>

        <pre>
          <code>
    <span class="l-python-orange">class</span> Funcionario: 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome, salario): 
        <span class="l-python-violeta">self</span>.nome = nome 
        <span class="l-python-violeta">self</span>.salario = salario 
           
    <span class="l-python-orange">def</span> <span class="l-python-blue">aplicaAumento</span>(<span class="l-python-violeta">self</span>, aumento): 
        <span class="l-python-violeta">self</span>.salario += aumento 
           
    <span class="l-python-orange">def</span> <span class="l-python-roxo">__str__</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-orange">return</span> <span class="l-python-green">f"Nome:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome<span class="l-python-orange">}</span><span class="l-python-green">, Salário:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.salario<span class="l-python-orange">}</span><span class="l-python-green">"</span> 
           
    <span class="l-python-orange">class</span> Vendedor(Funcionario): 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome, salario, comissao): 
        <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(nome, salario) 
        <span class="l-python-violeta">self</span>.comissao = comissao 
           
    <span class="l-python-orange">def</span> <span class="l-python-blue">aplicaAumento</span>(<span class="l-python-violeta">self</span>, aumento): 
        <span class="l-python-aescuro">super</span>().aplicaAumento(aumento) 
        <span class="l-python-violeta">self</span>.comissao += aumento 
           
    <span class="l-python-orange">def</span> <span class="l-python-roxo">__str__</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-orange">return</span> <span class="l-python-green">f"Nome:</span> <span class="l-python-orange">{</span>self.nome<span class="l-python-orange">}</span><span class="l-python-green">, Salário:</span> <span class="l-python-orange">{</span>self.salario<span class="l-python-orange">}</span><span class="l-python-green">, Comissão:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.comissao<span class="">}</span><span class="l-python-green">"</span> 
           
    <span class="l-python-orange">class</span> Administrativo(Funcionario): 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome, salario, cargo): 
        <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(nome, salario) 
        <span class="l-python-violeta">self</span>.cargo = cargo 
           
    <span class="l-python-orange">def</span> __str__(<span class="l-python-violeta">self</span>): 
        <span class="l-python-orange">return</span> <span class="l-python-green">f"Nome:</span> <span class="l-python-orange">{</span><pan class="l-python-violeta">self</pan>.nome<span class="l-python-orange">}</span><span class="l-python-green">, Salário:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.salario<span class="l-python-orange">}</span><span claEss="l-python-green">, Cargo:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.cargo<span class="l-python-orange">}</span><span class="l-python-green">"</span> 
           
# Exemplos de criação de objetos 
funcionario1 = Vendedor(<span class="l-python-green">"João"</span>, <span class="l-python-aqua">3000.0</span>, <span class="l-python-aqua">500.0</span>) 
funcionario2 = Administrativo(<span class="l-python-green">"Maria"</span>, <span class="l-python-aqua">3500.0</span>, <span class="l-python-green">"Assistente"</span>) 
           
# Listar vendedores 
print(<span class="l-python-green">"Vendedores:"</span>) 
print(funcionario1) 
           
# Listar funcionários administrativos 
print(<span class="l-python-green">"</span><span class="l-python-orange">\n</span><span class="l-python-green">Funcionários Administrativos:"</span>) 
print(funcionario2) 
           
#executa método para aumentar salário 
funcionario1.aplicaAumento(<span class="l-python-aqua">500.0</span>) 
funcionario2.aplicaAumento(<span class="l-python-aqua">450.0</span>) 
           
           
print(<span class="l-python-green">'</span><span class="l-python-orange">\n\n</span><span class="l-python-green">Listar com aumento'</span>) 
# Listar vendedores 
print(<span class="l-python-green">"Vendedores:"</span>) 
print(funcionario1) 
           
# Listar funcionários administrativos 
print(<span class="l-python-green">"</span><span class="l-python-orange">\n</span><span class="l-python-green">Funcionários Administrativos:"</span>) 
print(funcionario2) 
          </code>
        </pre>
        
        <p>
          Nesse exemplo, há uma classe-base Funcionario, com atributos comuns, como nome e salário,
          além
          de um
          método aplicaAumento. As classes Vendedor e Administrativo herdam da classe Funcionario e
          podem
          adicionar atributos específicos e sobrescrever o método aplicaAumento, conforme necessário.
          Os
          exemplos de criação de objetos demonstram como criar funcionários, aplicar aumentos e
          imprimir
          informações sobre eles.
        </p>

        <p>Saída do programa: </p>
        <img src="objetos/imagem_saida1.png" class="img-responsive center-block">

        <div class="acessivel print">
            <p>Vendedores:</p>
            <p>Nome: João, Salário: 3000.0, Comissão: 500.0</p>

            <p>Funcionários Administrativos:</p>
            <p>Nome: Maria, Salário: 3500.0, Cargo: Assistente</p>


            <p>Listar com aumento</p>
            <p>Vendedores:</p>
            <p>Nome: João, Salário: 3500.0, Comissão: 1000.0</p>

            <p>Funcionários Administrativos:</p>
            <p>Nome: Maria, Salário: 3950.0, Cargo: Assistente</p>

            <p>Process finished with exit code 0</p>
        </div>
        
        <div class='caixa-destaque-livre bg-primaria-02 borda-primaria-03 icone desafio no-print'
        aria-hidden="true">
        <ul id='abas01' class='nav nav-tabs' role='tablist'>
            <li role='presentation' class='active'><a href='#home' aria-controls='home' role='tab'
                    data-toggle='tab'>Desafio 1</a></li>
            <li role='presentation'><a href='#profile' aria-controls='profile' role='tab'
                    data-toggle='tab'>Desafio
                    2</a></li>
        </ul>
        <div class='tab-content'>
            <div role='tabpanel' class='tab-pane fade in active' id='home'>
                <p>Crie em um programa <strong>Python</strong> uma aplicação que leia dados de
                    cartões
                    de débito e crédito.
                    Use uma
                    hierarquia de classes, sabendo que</p>
                <ul class="cor01">
                    <li>todos os cartões contêm número do cartão, nome do portador, validade e
                        código de
                        segurança.</li>
                    <li>cartões de crédito possuem ainda um limite.</li>
                    <li>cartões de débito necessitam da informação de saldo atual em conta. </li>
                </ul>
                <p>No programa, o usuário informará se o cartão que cadastrará é de crédito ou
                    débito;
                    em seguida,
                    informará os dados desse cartão.</p>
            </div>
            <div role='tabpanel' class='tab-pane fade' id='profile'>
                <p>Expanda o programa do desafio anterior solicitando ao usuário um valor de compra.
                    De
                    acordo com o
                    valor, mostre mensagem de erro se o limite estourar no crédito ou se o saldo for
                    insuficiente no débito;
                    mostre mensagem de sucesso caso contrário.</p>
            </div>
        </div>
        </div>
    
        <div class="acessivel print">
            <h4>Desafio 1</h4>
            <p>Crie em um programa Python uma aplicação que leia dados de cartões de débito e crédito.
                Use
                uma
                hierarquia de
                classes, sabendo que</p>
            <ul class="cor01">
                <li>todos os cartões contêm número do cartão, nome do portador, validade e código de
                    segurança.</li>
                <li>cartões de crédito possuem ainda um limite.</li>
                <li>cartões de débito necessitam da informação de saldo atual em conta. </li>
            </ul>
            <p>No programa, o usuário informará se o cartão que cadastrará é de crédito ou débito; em
                seguida, informará
                os dados desse cartão.</p>
            <h4>Desafio 2</h4>
            <p>Expanda o programa do desafio anterior solicitando ao usuário um valor de compra. De
                acordo
                com o valor,
                mostre mensagem de erro se o limite estourar no crédito ou se o saldo for insuficiente
                no
                débito; mostre
                mensagem de sucesso caso contrário.
            </p>
        </div>

        <h4>Método construtor e método “super”</h4>

        <p>Em Python, os métodos construtores e a função super() são usados para lidar com herança e inicialização de objetos em classes derivadas (subclasses) e classes-base (superclasses).</p>

        <div class='caixa-destaque-livre bg-primaria-02 borda-primaria-03 no-print' aria-hidden="true">
          <ul id='abas02' class='nav nav-tabs' role='tablist'>
              <li role='presentation' class='active'><a href='#home1' aria-controls='home' role='tab'
                      data-toggle='tab'>Método Construtor (__init__) </a></li>
              <li role='presentation'><a href='#profile1' aria-controls='profile' role='tab'
                      data-toggle='tab'>Função super()</a></li>
          </ul>
          <div class='tab-content'>
              <div role='tabpanel' class='tab-pane fade in active' id='home1'>
                  <ul class="cor01 pad-top">
                      <li>É um método especial em Python, que é chamado quando um objeto da classe é
                          criado.</li>
                      <li>Seu nome é __init__, usado para inicializar os atributos do objeto. </li>
                      <li>Pode receber parâmetros que são usados para inicializar os atributos da
                          classe.
                      </li>
                      <li>Pode ser definido em uma classe derivada para adicionar inicializações
                          específicas dessa classe, mas ainda deve chamar o construtor da classe-base
                          usando super().__init__(), para garantir que os atributos da classe-base
                          sejam
                          inicializados corretamente. </li>
                  </ul>
              </div>
              <div role='tabpanel' class='tab-pane fade' id='profile1'>
                  <ul class="cor01 pad-top">
                      <li>É usada para chamar métodos da classe-base a partir de uma classe derivada.
                      </li>
                      <li>É frequentemente usada no construtor (__init__) de uma classe derivada para
                          chamar o construtor da classe-base. </li>
                      <li>Permite que você acesse os métodos e atributos da classe-base na classe
                          derivada.
                      </li>
                      <li>A chamada super().__init__() é usada para chamar o construtor da classe-base
                          a
                          partir do construtor da classe derivada. </li>
                  </ul>
              </div>
          </div>
        </div>
        <div class="acessivel print">
            <h3>Método Construtor (__init__)</h3>
            <ul>
                <li>É um método especial em Python, que é chamado quando um objeto da classe é
                    criado.</li>
                <li>Seu nome é __init__, usado para inicializar os atributos do objeto. </li>
                <li>Pode receber parâmetros que são usados para inicializar os atributos da classe.
                </li>
                <li>Pode ser definido em uma classe derivada para adicionar inicializações
                    específicas dessa classe, mas ainda deve chamar o construtor da classe-base
                    usando super().__init__(), para garantir que os atributos da classe-base sejam
                    inicializados corretamente. </li>
            </ul>
            <h3>Função super()</h3>
            <ul>
                <li>É usada para chamar métodos da classe-base a partir de uma classe derivada.
                </li>
                <li>É frequentemente usada no construtor (__init__) de uma classe derivada para
                    chamar o construtor da classe-base. </li>
                <li>Permite que você acesse os métodos e atributos da classe-base na classe
                    derivada.
                </li>
                <li>A chamada super().__init__() é usada para chamar o construtor da classe-base a
                    partir do construtor da classe derivada. </li>
            </ul>

        </div>

        <p>Sintaxe: </p>

        <pre>
            <code>
    <span class="l-python-orange">class</span> ClasseBase: 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, atributo_base): 
            <span class="l-python-violeta">self</span>.atributo_base = atributo_base 

    <span class="l-python-orange">class</span> ClasseDerivada(ClasseBase): 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(self, atributo_base, atributo_derivado): 
            <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(atributo_base)  # Chama o construtor da classe base 
            <span class="l-python-violeta">self</span>.atributo_derivado = atributo_derivado 

  objeto = ClasseDerivada(<span class="l-python-green">"Base"</span>, <span class="l-python-green">"Derivado"</span>) 
  <span class="l-python-aescuro">print</span>(objeto.atributo_base)  # Acesso ao atributo da classe base 
  <span class="l-python-aescuro">print</span>(objeto.atributo_derivado)  # Acesso ao atributo da classe derivada 
            </code>
        </pre>

        <p>
            Nesse exemplo, super().__init__(atributo_base) é usado na classe derivada para chamar o
            construtor
            da classe-base e inicializar o atributo atributo_base. Isso permite que a classe derivada
            herde
            e
            estenda o comportamento da classe-base.
        </p>
        <p>
            Em Python, você pode inicializar os atributos da superclasse (classe “Pessoa”) ao instanciar
            a
            classe “Aluno”, passando os valores necessários para o construtor da superclasse. Veja no
            exemplo a
            seguir:
        </p>

        <pre>
            <code>
    <span class="l-python-orange">class</span> Pessoa: 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome, cpf): 
            <span class="l-python-violeta">self</span>.nome = nome 
            <span class="l-python-violeta">self</span>.cpf = cpf 
            
        <span class="l-python-orange">def</span> <span class="l-python-blue">apresentar</span>(<span class="l-python-violeta">self</span>): 
            <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Nome:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
            <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"CPF:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.cpf<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
            
    <span class="l-python-orange">class</span> Aluno(Pessoa): 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome, cpf, matricula): 
            # Chama o construtor da superclasse (Pessoa) com os valores necessários 
            <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(nome, cpf) 
            <span class="l-python-violeta">self</span>.matricula = matricula 
            
        <span class="l-python-orange">def</span> <span class="l-python-blue">apresentar</span>(<span class="l-python-violeta">self</span>): 
            <span class="l-python-aescuro">super</span>().apresentar() 
            <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Matrícula:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.matricula<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
            
  # Exemplo de criação de um objeto Aluno com atributos inicializados 
  aluno = Aluno(<span class="l-python-green">"João"</span>, <span class="l-python-green">"123.456.789-00"</span>, <span class="l-python-green">"A12345"</span>) 
            
  # Chamando o método apresentar da classe Aluno 
  aluno.apresentar() 
            </code>
        </pre>
        
        <p>
            A classe “Aluno” herda de “Pessoa” e tem um construtor próprio que inicializa seu atributo
            específico, que é a matrícula. Para inicializar os atributos da superclasse “Pessoa” ao
            instanciar
            “Aluno”, é usado super().__init__(nome, cpf) dentro do construtor da classe “Aluno”. Isso
            garante
            que os atributos da superclasse sejam inicializados corretamente quando um objeto “Aluno” é
            criado.
        </p>

        <p>Saída do programa:</p>
        <img src="objetos/imagem_saida2.png" class="img-responsive center-block">
        <div class="acessivel print">
            <p>Nome: João</p>
            <p>CPF: 123.456.789-00</p>
            <p>Matrícula:A12345</p>

            <p>Process finished with exit code 0</p>
        </div>
       

        <h3>Superclasse</h3>
        <p>Como visto anteriormente, a superclasse é o nome utilizado para representar a classe mãe em uma estrutura de
          herança na programação orientada a objetos. Em uma herança, as classes filhas (subclasses) herdam os atributos
          e métodos públicos ou protegidos da superclasse.</p>
        <p>Ainda recordando o exemplo anterior, utiliza-se o método <b>super()</b> na subclasse para <b>construir</b>
          (utilizando o método construtor) a superclasse dentro (a partir) da subclasse. Isso acontece porque a
          palavra-chave "super" é utilizada para referenciar a superclasse dentro do contexto de uma subclasse.</p>
        <p>Com isso, outros métodos da superclasse podem ser acessados a partir da subclasse, não se limitando apenas ao
          método construtor, como visto no exemplo apresentado. Confira o código a seguir:</p>

          <pre>
            <code>
# Definindo a superclasse "Automovel" 
    <span class="l-python-orange">class</span> Automovel: 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, potencia): 
        <span class="l-python-violeta">self</span>.potencia = potencia 
                 
        <span class="l-python-orange">def</span> <span class="l-python-blue">imprimirDados</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Potência do Automóvel:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.potencia<span class="l-python-orange">}</span> <span class="l-python-green">cavalos"</span>) 
                 
# Definindo a subclasse "Carro" que herda de "Automovel" 
    <span class="l-python-orange">class</span> Carro(Automovel): 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, potencia, consumo): 
# Chama o construtor da superclasse (Automovel) 
        <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(potencia) 
        <span class="l-python-violeta">self</span>.consumo = consumo 
                 
        <span class="l-python-orange">def</span> <span class="l-python-blue">imprimirDados</span>(<span class="l-python-violeta">self</span>): 
# Chama o método da superclasse (Automovel) 
        <span class="l-python-aescuro">super</span>().imprimirDados() 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Consumo do Carro:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.consumo<span class="l-python-orange">}</span> <span class="l-python-green">km/l"</span>) 
                 
# Exemplo de criação de um objeto Carro 
carro = Carro(<span class="l-python-aqua">150</span>, <span class="l-python-aqua">12</span>)  # Potência de 150 cavalos e consumo de 12 km/l 
                 
# Chamando o método imprimirDados da classe Carro 
carro.imprimirDados() 
            </code>
          </pre>


          <p>
            No exemplo, a classe “Automovel” está como superclasse e a classe “Carro” como subclasse. A
            superclasse “Automovel” tem um atributo "potencia" e um método “imprimirDados”, que imprime
            a
            potência do automóvel. A subclasse “Carro” herda da superclasse e adiciona seu atributo
            “consumo” e
            um método “imprimirDados”, que imprime o consumo do carro.
        </p>
        <p>
            Ao criar um objeto da classe “Carro” e chamar o método “imprimirDados”", você verá que ambos
            os
            métodos da superclasse e da subclasse são chamados, demonstrando o uso da palavra-chave
            “super”
            para
            acessar métodos da superclasse a partir da subclasse. Isso ilustra o conceito de herança e
            superclasse em Python.
        </p>


        <p>Saída do programa: </p>
                    <pre>
                        <code>
Potência do Automóvel: 150 cavalos
Consumo do Carro: 12 km/l
Process finished with exit code 0
                        </code>
                    </pre>
       
        <div class="caixa-destaque-livre bg-primaria-02 borda-primaria-03">
          <p><b>Exemplo 2</b>: um serviço de <i>streaming</i> tem disponíveis em seu catálogo diversos filmes. Cada um
            tem dados como título, ano, diretor(a), gênero, duração e produtora responsável; cada vídeo é capaz de fazer
            “play” – ou “tocar”. Algum tempo depois, o serviço começou a oferecer séries e cada episódio tem informações
            como título, ano, diretor(a), número do episódio, temporada e duração do episódio, e também pode “tocar”.
          </p>

          <p>Note que há uma porção de informações comuns entre filme e episódio, além do método <b>tocar()</b> presente
            em ambas as classes. Essa é uma situação propícia para aplicar herança: pode-se considerar ambos,
            genericamente, como “vídeos”. Em um diagrama UML, você teria o seguinte:</p>

          <img src="objetos/layout_5_fig5.png" class="img-responsive center-block">
          <p class="legenda-imagem">
            Classes “Video” e suas derivadas “Filme” e “Episodio”
            Fonte: Senac EAD (2024)
          </p>

          <p class="acessivel no-print">Diagrama da classe “Video” com os atributos “titulo: String”, “direcao: String”,
            “ano: int”, “duração: float” e o método “tocar()”. Setas de hierarquia ligam à esquerda com a classe
            “Filme”, com os atributos “gênero: String” e “produtora: String”. À direita, a hierarquia se liga com
            “Episodio”, com os atributos “episodio:int”, “temporada:int”.</p>
        </div>

        <p>Em Python, é possível criar as classes como o seguinte exemplo:</p>

        <pre>
          <code>
    <span class="l-python-orange">class</span> Video: 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-violeta">self</span>.titulo = <span class="l-python-green">""</span> 
        <span class="l-python-violeta">self</span>.direcao = <span class="l-python-green">""</span> 
        <span class="l-python-violeta">self</span>.ano = <span class="l-python-aqua">0</span> 
        <span class="l-python-violeta">self</span>.duracao = <span class="l-python-aqua">0.0</span> 

    <span class="l-python-orange">def</span> <span class="l-python-blue">tocar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Tocando</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span class="l-python-violeta">.titulo<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Classe para representar filmes, que herda de Video 
    <span class="l-python-orange">class</span> Filme(Video): 
        <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__()</span> 
        <span class="l-python-violeta">self</span>.genero = <span class="l-python-green">""</span> 
        <span class="l-python-violeta">self</span>.produtora = <span class="l-python-green">""</span> 

    <span class="l-python-orange">def</span> <span class="l-python-blue">informacoes</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Filme:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.titulo<span class="l-python-orange">}</span> <span class="l-python-green">(</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.ano<span class="l-python-orange">}</span><span class="l-python-green">)"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Diretor(a):</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.direcao<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Gênero:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.genero<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Duração:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.duracao<span class="l-python-orange">}</span> <span class="l-python-green">minutos"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Produtora:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.produtora<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Classe para representar episódios de séries, que herda de Video 
    <span class="l-python-orange">class</span> Episodio(Video): 
<span class="l-python-orange">def</span><span class="l-python-roxo"> __init__</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>() 
        <span class="l-python-violeta">self</span>.episodio = <span class="l-python-aqua">0</span> 
        <span class="l-python-violeta">self</span>.temporada = <span class="l-python-aqua">0</span> 

    <span class="l-python-orange">def</span> <span class="l-python-blue">informacoes</span>(<span class="l-python-violeta">self</span>): 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Episódio:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.titulo<span class="l-python-orange">}</span> <span class="l-python-green">(Temporada</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.temporada<span class="l-python-orange">}</span><span class="l-python-green">, Episódio</span> {<span class="l-python-violeta">self</span>.episodio<span class="l-python-orange">}</span><span class="l-python-green">,</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.ano<span class="l-python-orange">}</span><span class="l-python-green">)"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Diretor(a):</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.direcao<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
        <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Duração:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.duracao<span class="l-python-orange">}</span> <span class="l-python-green">minutos"</span>) 

# Criando objetos 
v = Video() 
f = Filme() 
e = Episodio() 

v.titulo = <span class="l-python-green">"Video genérico"</span> 
v.direcao = <span class="l-python-green">"Francisco da Silva"</span> 
v.ano = <span class="l-python-aqua">2022</span> 
v.duracao = <span class="l-python-aqua">30</span> 

f.titulo = <span class="l-python-green">"Aventuras nos Alpes"</span> 
f.direcao = <span class="l-python-green">"Joana da Silva"</span> 
f.ano = <span class="l-python-aqua">2000</span> 
f.duracao = <span class="l-python-aqua">120</span> 
f.genero = <span class="l-python-green">"Aventura"</span> 
f.produtora = <span class="l-python-green">"Sun Films"</span> 

e.titulo = <span class="l-python-green">"Tecnologias perigosas" </span>
e.direcao = <span class="l-python-green">"Joaquim da Silva"</span> 
e.ano = <span class="l-python-aqua">2021</span> 
e.duracao = <span class="l-python-aqua">45</span> 
e.episodio = <span class="l-python-aqua">5</span> 
e.temporada = <span class="l-python-aqua">1</span> 

# Tocando os vídeos 
v.tocar() 
f.tocar() 
e.tocar() 

# Exibindo informações detalhadas 
f.informacoes() 
e.informacoes()
          </code>
        </pre>
        
        <p>
          Nesse exemplo em Python, foram criados objetos das classes “Video”, “Filme” e “Episodio” e
          definidos os atributos de cada objeto, com os valores correspondentes. Em seguida, foi
          chamado o
          método “tocar” em cada objeto, para simular a reprodução dos vídeos, e exibidas as
          informações
          detalhadas para os objetos das classes “Filme” e “Episodio”. O código Python reflete a
          estrutura
          do código Python fornecido.
      </p>
      <p>Saída do programa: </p>

      <pre>
          <code>
Tocando Video genérico
Tocando Aventuras nos Alpes
Tocando Tecnologias perigosas
Filme: Aventuras nos Alpes (2000)
Diretor(a): Joana da Silva
Gênero: Aventura
Duração: 120 minutos
Produtora: Sun Films
Episódio: Tecnologias perigosas (Temporada 1, Episódio 5, 2021)
Diretor(a): Joaquim da Silva
Duração: 45 minutos

Process finished with exit code 0
          </code>
      </pre>
        
      
      </div>

      <div class="pagina">
        <h3>Classes abstratas</h3>
        <p>Uma classe abstrata é uma categoria especial de classe. Isso porque não se pode instanciar objetos de uma
          classe abstrata, como usualmente se faz com uma classe normal. Uma classe abstrata funciona como um "modelo"
          para outras classes, um "protocolo" a ser seguido.</p>

        <img src="objetos/layout_5_fig6.png" class="img-responsive center-block">
        <p class="legenda-imagem">
          Árvores <br>
          Fonte: Freepik (c2010-2022)
        </p>

        <p class="acessivel no-print">A imagem contém a ilustração de trinta e duas árvores diferentes uma da outra,
          dispostas em cinco fileiras.</p>

        <p>A imagem mostra diferentes árvores que, se representadas em orientação a objetos, poderiam derivar de uma
          classe abstrata <b>Árvore</b>, que apenas dita as características mais gerais de uma árvore.</p>

        <div class="caixa-destaque icone anotar">
          <p>Entende-se que árvores seguem um modelo de abstração. Todas as árvores contêm características e
            comportamentos em comum, o que permite identificar o que é uma árvore ou não, sem precisar conhecer todas as
            espécies de árvores.</p>
        </div>

        <p>A utilização de uma classe abstrata traz um novo conceito para a programação orientada a objetos. Trata-se
          dos métodos <b>concretos</b> e <b>abstratos</b>.</p>
        <div>

          <h4>Métodos concretos</h4>
          <p>Métodos concretos são os métodos já conhecidos e utilizados diversas vezes. Já os métodos abstratos são,
            assim como as classes abstratas, apenas "modelos", "protocolos", e não contêm uma
            implementação/comportamento.</p>

            <p>
              Em Python, as classes abstratas são uma maneira de definir classes que não podem ser
              instanciadas
              diretamente, mas fornecem uma estrutura comum e definições de métodos que devem ser
              implementados
              por suas subclasses concretas. As classes abstratas são úteis para criar uma hierarquia de
              classes,
              garantindo a presença de determinados métodos em todas as subclasses, mas sem permitir a criação
              de
              objetos diretamente a partir da classe abstrata.
          </p>
          <p>
              Para criar uma classe abstrata em Python, geralmente é usado o módulo abc (<i>abstract base
                  classes</i>). A
              seguir, veja os passos básicos para criar e usar classes abstratas em Python.
          </p>

          <!-- INFOGRAFICO -->

          <img src="./objetos/infografico_modal2.png" class="img-responsive center-block" alt="" srcset="">

          <div class="acessivel print">
              <ol>
                  <li>Importe o módulo abc. </li>
                  <li>Defina uma classe que herda de abc (<i>abstract base class</i>) e use o decorador
                      @abstractmethod para definir métodos abstratos. Um método abstrato é um método que deve
                      ser implementado por todas as subclasses. </li>
                  <li>Crie subclasses que herdam da classe abstrata e implemente todos os métodos abstratos.
                  </li>
              </ol>
          </div>
          <p>Observe como criar e usar classes abstratas em Python: </p>
          <pre>
              <code>
<span class="l-python-orange">rom</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

<span class="l-python-orange">class</span> Conta(ABC): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-violeta">self</span>.saldo = <span class="l-python-aqua">0.0</span> 

<span class="l-python-orange">def</span> <span class="l-python-blue">set_saldo</span>(<span class="l-python-violeta">self</span>, saldo): 
<span class="l-python-violeta">self</span>.saldo = saldo 

<span class="l-python-orange">def</span> <span class="l-python-blue">get_saldo</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.saldo 

<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">imprimir_extrato</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 

# Exemplo de uma subclasse concreta de Conta 
<span class="l-python-orange">class</span> ContaCorrente(Conta): 
<span class="l-python-orange">def</span> <span class="l-python-blue">imprimir_extrato</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Saldo da Conta Corrente:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.get_saldo()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Exemplo de outra subclasse concreta de Conta 
<span class="l-python-orange">class</span> ContaPoupanca(Conta): 
<span class="l-python-orange">def</span> <span class="l-python-blue">imprimir_extrato</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Saldo da Conta Poupança:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.get_saldo()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Você não pode criar uma instância da classe abstrata Conta 
# conta = Conta() 

# No entanto, você pode criar instâncias de suas subclasses concretas 
conta_corrente = ContaCorrente() 
conta_poupanca = ContaPoupanca() 

# Definindo saldo para as contas 
conta_corrente.set_saldo(<span class="l-python-aqua">1000.0</span>) 
conta_poupanca.set_saldo(<span class="l-python-aqua">500.0</span>) 

# Imprimindo extratos 
conta_corrente.imprimir_extrato() 
conta_poupanca.imprimir_extrato() 
              </code>
          </pre>
          <p>
              Neste exemplo, a classe Conta é uma classe abstrata com um método abstrato imprimir_extrato().
              As
              subclasses concretas ContaCorrente e ContaPoupanca herdam de Conta e implementam o método
              imprimir_extrato. Você não pode criar uma instância direta da classe abstrata Conta, mas pode
              criar
              instâncias de suas subclasses concretas e usar os métodos definidos na classe abstrata.
          </p>
          <p>
              Se você tentar criar uma instância direta da classe abstrata <b>Conta</b> em Python usando conta
              =
              <b>Conta()</b>,
              você receberá um erro <b>TypeError</b>. A tentativa de instanciar uma classe abstrata resulta em
              um
              erro,
              pois as classes abstratas não devem ser instanciadas diretamente. Elas existem para fornecer uma
              estrutura comum e definir métodos abstratos que devem ser implementados por suas subclasses
              concretas.
          </p>
          <p>
              Ao tentar criar uma instância de uma classe abstrata, você verá uma mensagem de erro semelhante
              a
              esta:
          </p>
          <pre>
              <code>
                  TypeError: <span class="l-python-verde-oliva">Can't instantiate abstract class Conta with abstract methods imprimir_extrato</span>
              </code>
          </pre>
          <p>
              A classe <b>Conta</b> é abstrata e possui um método abstrato <b>imprimir_extrato</b>, que deve
              ser implementado
              por suas subclasses concretas. Portanto, você deve criar instâncias das subclasses concretas
              (como
              <b>ContaCorrente</b> e <b>ContaPoupanca</b>) e não da classe abstrata <b>Conta</b>.
          </p>
          <div class="caixa-destaque-livre bg-primaria-02 borda-primaria-03">
              <p>
                  <b>Exemplo 3:</b> uma empresa precisa emitir relatórios periódicos de vendas e de gastos. Os
                  relatórios
                  seguem um padrão de cabeçalho e rodapé e todos usam informações com nome da empresa e
                  sumarização de valores. Será programada uma aplicação Python que esboce uma solução para
                  essa
                  situação, com uma classe-base Relatorio, que garantirá cabeçalho e rodapé-padrão, além das
                  informações extras.
              </p>
          </div>
          <p>Considere uma classe-base <b>Relatorio</b>. Ela garantirá um cabeçalho e rodapé padrões, além das
              informações extras.
          </p>
          <pre>
              <code>
<span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

# Classe base abstrata Relatorio 
<span class="l-python-orange">class</span> Relatorio(ABC): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome_empresa, data): 
<span class="l-python-violeta">self</span>.nome_empresa = nome_empresa 
<span class="l-python-violeta">self</span>.data = data 

<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">corpo_relatorio</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 

# Método para gerar o relatório completo 
<span class="l-python-orange">def</span> <span class="l-python-blue">gerar_relatori</span>o(<span class="l-python-violeta">self</span>): 
<span class="l-python-violeta">self</span>.cabecalho() 
<span class="l-python-violeta">self</span>.corpo_relatorio() 
<span class="l-python-violeta">self</span>.rodape() 

# Método para exibir o cabeçalho padrão 
<span class="l-python-orange">def</span> <span class="l-python-blue">cabecalho</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"==================================="</span>) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Relatório de</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome_empresa<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Data:</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.data<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"==================================="</span>) 

# Método para exibir o rodapé padrão 
<span class="l-python-orange">def</span> <span class="l-python-blue">rodape</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"==================================="</span>) 

# Subclasse RelatorioVendas 
<span class="l-python-orange">class</span> RelatorioVendas(Relatorio): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome_empresa, data, total_vendas): 
<span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(nome_empresa, data) 
<span class="l-python-violeta">self</span>.total_vendas = total_vendas 

<span class="l-python-orange">def</span> <span class="l-python-blue">corpo_relatorio</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Relatório de Vendas"</span>) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Total de Vendas: R$</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.total_vendas<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Subclasse RelatorioGastos 
<span class="l-python-orange">class</span> RelatorioGastos(Relatorio): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome_empresa, data, total_gastos): 
<span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(nome_empresa, data) 
<span class="l-python-violeta">self</span>.total_gastos = total_gastos 

<span class="l-python-orange">def</span> <span class="l-python-blue">corpo_relatorio</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Relatório de Gastos"</span>) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Total de Gastos: R$</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.total_gastos<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Exemplo de uso 
relatorio_vendas = RelatorioVendas(<span class="l-python-green">"Minha Empresa"</span>, <span class="l-python-green">"2023-10-15"</span>, <span class="l-python-aqua">10000</span>) 
relatorio_gastos = RelatorioGastos(<span class="l-python-green">"Minha Empresa"</span>, <span class="l-python-green">"2023-10-15"</span>, <span class="l-python-aqua">7500</span>) 

relatorio_vendas.gerar_relatorio() 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"</span><span class="l-python-orange">\n</span><span class="l-python-green">"</span>) 
relatorio_gastos.gerar_relatorio() 
              </code>
          </pre>
          <p>
              No exemplo, há uma classe abstrata Relatorio, que define cabeçalho e rodapé e o método abstrato
              corpo_relatorio. As subclasses concretas RelatorioVendas e RelatorioGastos herdam de Relatorio e
              implementam o método corpo_relatorio com informações específicas para vendas e gastos. Cada uma
              delas também pode ser gerada usando o método gerar_relatorio(). Isso permite criar relatórios
              com
              cabeçalho e rodapé-padrão, independentemente do tipo de relatório que você deseja gerar.
          </p>
          <p> Saída do programa:</p>
          <pre>
                  <code>
=================================== 
Relatório de Minha Empresa 
Data: 2023-10-15 
=================================== 
Relatório de Vendas 
Total de Vendas: R$ 10000 
=================================== 


=================================== 
Relatório de Minha Empresa 
Data: 2023-10-15 
=================================== 
Relatório de Gastos 
Total de Gastos: R$ 7500 
=================================== 


Process finished with exit code 0 
                  </code>
              </pre>
          <div class="caixa-destaque icone desafio">
              <p>
                  Crie uma classe Produto, com nome e valor; crie uma classe abstrata Loja, com método
                  abstrato
                  “lista valores” e uma lista de produtos e crie duas classes concretas implementando a classe
                  Loja: classe “loja suburbio”, em que os preços são mostrados na tela com 10% de desconto, e
                  “loja shopping”, em que os preços dos produtos são listados com adição de 15% do valor
                  original.
              </p>
              <button type="button" class="botao bg-primaria-03 texto-primaria-02 mt-60 centralizar no-print"
                  data-toggle="modal" data-target="#modal-desafio1">Gabarito</button>

              <div class="modal modal-100 fade" id="modal-desafio1" aria-hidden="true">
                  <div class="modal-dialog">
                      <div class="modal-content no-print">
                          <div class="modal-header" style="padding-top: 30px;">
                              <button type="button" class="close" data-dismiss="modal"
                                  aria-label="Close"><span aria-hidden="true">×</span></button>
                              <h3 class="modal-title">
                                  <div class="container">GABARITO DO DESAFIO</div>
                              </h3>
                          </div>
                          <div class="modal-body">
                              <div class="container">
                                  <pre>
                                  <code>
<span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

# Classe Produto com nome e valor 
<span class="l-python-orange">class</span> Produto: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome, valor): 
<span class="l-python-violeta">self</span>.nome = nome 
<span class="l-python-violeta">self</span>.valor = valor 

# Classe abstrata Loja com método abstrato "lista_valores" e lista de produtos 
<span class="l-python-orange">class</span> Loja(ABC): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-violeta">self</span>.produtos = [] 

<span class="l-python-amarelo">@abstractmethod </span>
<span class="l-python-orange">def</span> <span class="l-python-blue">lista_valores</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 

# Método para adicionar produtos à lista da loja 
<span class="l-python-orange">def</span> <span class="l-python-blue">adiciona_produto</span>(<span class="l-python-violeta">self</span>, produto): 
<span class="l-python-violeta">self</span>.produtos.append(produto) 

# Classe concreta LojaSuburbio que herda de Loja 
<span class="l-python-orange">class</span> LojaSuburbio(Loja): 
# Implementação do método abstrato "lista_valores" com desconto de 10% 
<span class="l-python-orange">def</span> <span class="l-python-blue">lista_valores</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Loja Subúrbio - Preços com 10% de desconto:"</span>) 
<span class="l-python-orange">for</span> produto <span class="l-python-orange">in</span> <span class="l-python-violeta">self</span>.produtos: 
  preco_com_desconto = produto.valor * <span class="l-python-aqua">0.9</span>  # Aplica desconto de 10% 
  <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>produto.nome<span class="l-python-orange">}</span><span class="l-python-green">: R$</span> <span class="l-python-orange">{</span>preco_com_desconto<span class="l-python-orange">:</span><span class="l-python-green">.2f</span><span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Classe concreta LojaShopping que herda de Loja 
<span class="l-python-orange">class</span> LojaShopping(Loja): 
# Implementação do método abstrato "lista_valores" com acréscimo de 15% 
<span class="l-python-orange">def</span> <span class="l-python-blue">lista_valores</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Loja Shopping - Preços com 15% de acréscimo:"</span>) 
<span class="l-python-orange">for</span> produto <span class="l-python-orange">in</span> <span class="l-python-violeta">self</span>.produtos: 
  preco_com_acrescimo = produto.valor * <span class="l-python-aqua">1.15</span>  # Acréscimo de 15% 
  <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>produto.nome}<span class="l-python-green">: R$</span> <span class="l-python-orange">{</span>preco_com_acrescimo<span class="l-python-orange">:</span><span class="l-python-green">.2f</span><span class="l-python-orange">}</span><span class="l-python-green">"</span>) 

# Exemplo de uso 
produto1 = Produto(<span class="l-python-green">"Camiseta"</span>, <span class="l-python-aqua">50.0</span>) 
produto2 = Produto(<span class="l-python-green">"Tênis"</span>, <span class="l-python-aqua">120.0</span>) 

loja_suburbio = LojaSuburbio() 
loja_shopping = LojaShopping() 

loja_suburbio.adiciona_produto(produto1) 
loja_shopping.adiciona_produto(produto1) 
loja_shopping.adiciona_produto(produto2) 

loja_suburbio.lista_valores() 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"</span><span class="l-python-orange">\n</span><span class="l-python-green">"</span>) 
loja_shopping.lista_valores() 
                                  </code>
                              </pre>
                                  <div class="modal-footer">
                                      <button type="button" class="btn btn-default"
                                          data-dismiss="modal">Fechar</button>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
          <p>
              Esse exemplo contém a classe Produto com nome e valor. A classe abstrata Loja define um método
              abstrato lista_valores e mantém uma lista de produtos. As classes concretas LojaSuburbio e
              LojaShopping herdam de Loja e implementam o método lista_valores com desconto de 10% e acréscimo
              de
              15%, respectivamente. O exemplo de uso demonstra como adicionar os produtos às lojas e listar os
              preços com os descontos ou acréscimos correspondentes.
          </p>
          <p> Saída do programa: </p>
          <pre>
              <code>
Loja Subúrbio - Preços com 10% de desconto: 
Camiseta: R$ 45.00 


Loja Shopping - Preços com 15% de acréscimo: 
Camiseta: R$ 57.50 
Tênis: R$ 138.00 

Process finished with exit code 0 
              </code>
          </pre>
          
        </div>
          
            

        
       
    
           
       
       <!--  -->

      </div>

      <div class="pagina">
        <h3>Interface</h3>
        <p>Interfaces são relativamente semelhantes a classes abstratas. Enquanto uma classe abstrata define métodos
          abstratos (servindo como um modelo para as subclasses – que herdam os seus métodos), uma interface é um
          "contrato", definindo um conjunto de métodos que serão implementados. Dessa forma, uma interface é
          completamente abstrata (não contém nenhum método concreto, diferente de uma classe abstrata).</p>
        
        <div class="caixa-destaque icone importante">
          <p>Uma classe só pode herdar uma única superclasse. Assim, quando se trabalha com classes abstratas, pode-se
            estender apenas uma classe abstrata, herdando os seus comportamentos e implementando os seus métodos
            abstratos.</p>    
        </div>

        <p>
          Em Python, não existe uma construção de linguagem chamada “interface” no sentido estrito como
          em
          algumas outras linguagens, como Python. No entanto, o Python oferece uma abordagem
          alternativa
          para a implementação de interfaces por meio de classes abstratas e módulos específicos, como
          abc
          (<i>abstract base classes</i>). Veja os conceitos-chave relacionados à implementação de
          interfaces em
          Python.
        </p>
  
        <div class="no-print" aria-hidden="true">
            <p>Clique ou toque para visualizar o conteúdo.</p>
            <div class="panel-group gaitinha" id="accordion" role="tablist" aria-multiselectable="true">
                <div class="panel panel-default">
                    <div class="panel-heading" role="tab" id="headingOne">
                        <h4 class="panel-title">
                            <a role="button" data-toggle="collapse" data-parent="#accordion"
                                href="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                                Classes abstratas (<i>abstract classes</i>)
                            </a>
                        </h4>
                    </div>
                    <div id="collapseOne" class="panel-collapse collapse in" role="tabpanel"
                        aria-labelledby="headingOne">
                        <div class="panel-body">
                            Você pode criar classes abstratas usando o módulo abc. Classes abstratas são
                            classes que podem conter métodos abstratos (métodos sem implementação), que
                            devem ser implementados por suas subclasses. Embora Python permita que você crie
                            objetos a partir de classes abstratas, o objetivo principal é fornecer uma
                            estrutura para a definição de interfaces e métodos que devem ser implementados.
                        </div>
                    </div>
                </div>
                <div class="panel panel-default">
                    <div class="panel-heading" role="tab" id="headingTwo">
                        <h4 class="panel-title">
                            <a class="collapsed" role="button" data-toggle="collapse"
                                data-parent="#accordion" href="#collapseTwo" aria-expanded="false"
                                aria-controls="collapseTwo">
                                Métodos abstratos (<i>abstract methods</i>)
                            </a>
                        </h4>
                    </div>
                    <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel"
                        aria-labelledby="headingTwo">
                        <div class="panel-body">
                            Um método abstrato é um método declarado em uma classe abstrata que não possui
                            implementação. Subclasses concretas da classe abstrata devem implementar esses
                            métodos abstratos. Isso força as subclasses a fornecer uma implementação
                            concreta para esses métodos.
                        </div>
                    </div>
                </div>
                <div class="panel panel-default">
                    <div class="panel-heading" role="tab" id="headingThree">
                        <h4 class="panel-title">
                            <a class="collapsed" role="button" data-toggle="collapse"
                                data-parent="#accordion" href="#collapseThree" aria-expanded="false"
                                aria-controls="collapseThree">
                                Módulo abc
                            </a>
                        </h4>
                    </div>
                    <div id="collapseThree" class="panel-collapse collapse" role="tabpanel"
                        aria-labelledby="headingThree">
                        <div class="panel-body">
                            O módulo abc (<i>abstract base classes</i>) em Python fornece a funcionalidade
                            para
                            criar classes abstratas e métodos abstratos. Você pode usar @abstractmethod como
                            um decorador para marcar métodos como abstratos.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="acessivel print">
        <h3>Classes abstratas (<i>abstract classes</i>)</h3>
        <p>
            Você pode criar classes abstratas usando o módulo abc. Classes abstratas são classes que
            podem
            conter métodos abstratos (métodos sem implementação), que devem ser implementados por suas
            subclasses. Embora Python permita que você crie objetos a partir de classes abstratas, o
            objetivo principal é fornecer uma estrutura para a definição de interfaces e métodos que
            devem
            ser implementados.
        </p>
        <h3>Métodos abstratos (<i>abstract methods</i>)</h3>
        <p>
            Um método abstrato é um método declarado em uma classe abstrata que não possui
            implementação.
            Subclasses concretas da classe abstrata devem implementar esses métodos abstratos. Isso
            força as
            subclasses a fornecer uma implementação concreta para esses métodos.
        </p>
        <h3>Módulo abc</h3>
        <p>
            O módulo abc (<i>abstract base classes</i>) em Python fornece a funcionalidade para criar
            classes
            abstratas e métodos abstratos. Você pode usar @abstractmethod como um decorador para marcar
            métodos como abstratos.
        </p>
        </div>
        <p>A seguir, veja um exemplo de como criar uma interface em Python usando classes abstratas. </p>
        
        <pre>
            <code>
<span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

# Classe abstrata que define uma interface 
<span class="l-python-orange">class</span> MinhaInterface(ABC): 
           
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">metodo_abstrato</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
           
# Classe concreta que implementa a interface 
<span class="l-python-orange">class</span> MinhaClasse(MinhaInterface): 
           
<span class="l-python-orange">def</span> <span class="l-python-blue">metodo_abstrato</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Método concreto implementado."</span>) 
           
# Criando uma instância da classe concreta 
obj = MinhaClasse() 
obj.metodo_abstrato() 
      </code>
        </pre>
        
        <p>
          No exemplo, MinhaInterface é uma classe abstrata que define um método abstrato metodo_abstrato.
          A
          classe concreta MinhaClasse herda de MinhaInterface e fornece uma implementação concreta para o
          método abstrato. Isso demonstra o uso de classes abstratas para definir interfaces em Python.
          Note
          que, em Python, isso é uma convenção, e não uma característica de linguagem estrita. As classes
          e os
          métodos marcados como abstratos servem como diretrizes para programadores, mas o Python não
          impede
          estritamente a criação de instâncias de classes abstratas.
        </p>

        <p>Saída do programa: </p>
  
        <pre>
      <code>
Método concreto implementado. 

Process finished with exit code 0 
      </code>
        </pre>
 
        <p>
          Sobre interfaces, <strong>uma classe pode implementar diversas interfaces</strong>. Por exemplo,
          imagine um canivete
          suíço: ele pode cortar como uma faca, abrir garrafas, abrir latas, sacar rolhas, serrar e furar.
          Ao
          abstrair isso para dentro de um código, poderia haver uma interface para cada comportamento,
          definindo os seus respectivos métodos (por exemplo, a interface faca pode cortar e afiar e a
          interface saca-rolha pode sacar uma rolha), e ser criada uma única classe “CaniveteSuico”, que
          implementaria todas essas interfaces.
        </p>
        
        <p>Acompanhe o código a seguir para ver um exemplo. </p>
        
        <pre>
            <code>
      <span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

      # Definição de interfaces 
      <span class="l-python-orange">class</span> Faca(ABC): 
      <span class="l-python-amarelo">@abstractmethod</span> 
      <span class="l-python-orange">def</span> <span class="l-python-blue">cortar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-orange">pass</span> 
                
      <span class="l-python-amarelo">@abstractmethod</span> 
      <span class="l-python-orange">def</span> <span class="l-python-blue">afiar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-orange">pass</span> 
                
      <span class="l-python-orange">class</span> AbreGarrafas(ABC): 
      <span class="l-python-amarelo">@abstractmethod</span> 
      <span class="l-python-orange">def</span> <span class="l-python-blue">abrir_garrafas</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-orange">pass</span> 
                
      <span class="l-python-orange">class</span> AbreLatas(ABC): 
      <span class="l-python-amarelo">@abstractmethod</span> 
      <span class="l-python-orange">def</span> <span class="l-python-blue">abrir_latas</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-orange">pass</span> 
                
      <span class="l-python-orange">class</span> SacaRolhas(ABC): 
      <span class="l-python-amarelo">@abstractmethod</span> 
      <span class="l-python-orange">def</span> <span class="l-python-blue">sacar_rolhas</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-orange">pass</span> 
                
      <span class="l-python-orange">class</span> Serra(ABC): 
      <span class="l-python-amarelo">@abstractmethod</span> 
      <span class="l-python-orange">def</span> <span class="l-python-blue">serrar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-orange"> pass</span> 
                
      <span class="l-python-orange">class</span> Fura(ABC): 
      <span class="l-python-amarelo">@abstractmethod</span> 
      <span class="l-python-orange">def</span> <span class="l-python-blue">furar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-orange">pass</span> 
                
      # Classe CaniveteSuico que implementa todas as interfaces 
      <span class="l-python-orange">class</span> CaniveteSuico(Faca, AbreGarrafas, AbreLatas, SacaRolhas, Serra, Fura): 
                
      <span class="l-python-orange">def</span> <span class="l-python-blue">cortar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Cortando com a faca."</span>) 
                
      <span class="l-python-orange">def</span> <span class="l-python-blue">afiar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Afiando com a faca."</span>) 
                
      <span class="l-python-orange">def</span> <span class="l-python-blue">abrir_garrafas</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Abrindo garrafas com o abridor de garrafas."</span>) 
                
      <span class="l-python-orange">def</span> <span class="l-python-blue">abrir_latas</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Abrindo latas com o abridor de latas."</span>) 
                
      <span class="l-python-orange">def</span> <span class="l-python-blue">sacar_rolhas</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Sacrando rolhas com o saca-rolhas."</span>) 
                
      <span class="l-python-orange">def</span> <span class="l-python-blue">serrar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-aescuro">print</span>(<spn class="l-python-green">"Serrando com a serra."</spn>) 
                
      <span class="l-python-orange">def</span> <span class="l-python-blue">furar</span>(<span class="l-python-violeta">self</span>): 
      <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Furando com o furador."</span>) 

      # Exemplo de uso 
      canivete = CaniveteSuico() 
      canivete.cortar() 
      canivete.abrir_garrafas() 
      canivete.abrir_latas() 
      canivete.sacar_rolhas() 
      canivete.serrar() 
      canivete.furar()
            </code>
        </pre>

        <p>
            Foram criadas várias interfaces, cada uma com seus métodos abstratos representando uma
            funcionalidade do canivete suíço. A classe CaniveteSuico implementa todas essas interfaces e
            fornece
            implementações concretas para os métodos abstratos. Quando você cria uma instância de
            CaniveteSuico,
            pode chamar os métodos correspondentes às funcionalidades do canivete suíço. Isso ilustra como
            simular interfaces em Python usando classes abstratas.
        </p>
  
        <p>Saída do programa: </p>

        <pre>
          <code>
Cortando com a faca. 
Abrindo garrafas com o abridor de garrafas. 
Abrindo latas com o abridor de latas. 
Sacrando rolhas com o saca-rolhas. 
Serrando com a serra. 
Furando com o furador. 

Process finished with exit code 0 
      </code>
        </pre>
  
        <p>
          Em Python, o termo “DAO” geralmente se refere a “Data Access Object”, que é um padrão de projeto
          utilizado para separar a lógica de acesso a dados do restante da aplicação. O objetivo do DAO é
          isolar o código que interage com o banco de dados, facilitando a manutenção e a escalabilidade
          da
          aplicação.
        </p>
  
        <p>
            Em Python, você não encontrará um equivalente exato chamado “APPDAO”, como em Python, mas o
            conceito
            de DAO é amplamente aplicável. Em Python, você pode criar módulos ou classes que desempenham
            funções
            semelhantes ao DAO, permitindo que você isole a lógica de acesso a dados.
        </p>
  
        <p> Veja como você pode criar uma classe de acesso a dados em Python:</p>
  
        <pre>
          <code>
<span class="l-python-orange">class</span> PessoaDAO: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, conexao): 
<span class="l-python-violeta">self</span>.conexao = conexao 
   
<span class="l-python-orange">def</span> <span class="l-python-blue">salvar</span>(<span class="l-python-violeta">self</span>, pessoa): 
# Lógica para salvar a pessoa no banco de dados 
<span class="l-python-orange">pass</span> 
   
<span class="l-python-orange">def</span> <span class="l-python-blue">buscar_por_id</span>(<span class="l-python-violeta">self</span>, id): 
# Lógica para buscar uma pessoa pelo ID 
<span class="l-python-orange">pass</span> 
   
<span class="l-python-orange">def</span> <span class="l-python-blue">atualizar</span>(<span class="l-python-violeta">self</span>, pessoa): 
# Lógica para atualizar os dados de uma pessoa no banco de dados 
<span class="l-python-orange">pass</span> 
   
<span class="l-python-orange">def</span> <span class="l-python-blue">deletar</span>(<span class="l-python-violeta">self</span>, pessoa): 
# Lógica para deletar uma pessoa do banco de dados 
<span class="l-python-orange">pass</span> 
          </code>
        </pre>
        <p>
          Pessoa DAO é uma classe que encapsula a lógica de acesso a dados relacionada a objetos “Pessoa”.
          Você pode criar instâncias dessa classe e chamar os métodos para salvar, buscar, atualizar e
          excluir
          objetos “Pessoa” no banco de dados.
        </p>

        <p>
          O uso de um padrão DAO em Python é flexível e pode variar de acordo com as necessidades do seu
          projeto. Você pode implementar as operações de acesso a dados de acordo com o banco de dados que
          está usando, por exemplo, SQLite, MySQL e PostgreSQL, ou usar uma biblioteca ORM
          (Object-Relational
          Mapping), como o SQLAlchemy, para abstrair a camada de acesso a dados.
        </p>

        <div class="caixa-destaque icone anotar">
            <p>
                DAO (Data Access Object – objeto de acesso a dados) é um conceito de programação, padrão
                para
                persistência de dados, no qual todas as funcionalidades de bancos de dados devem ser feitas
                por classes DAO.
            </p>
        </div>

        <div class="caixa-destaque-livre bg-primaria-02 borda-primaria-03">
            <p>
                <b> Exemplo 4:</b> programa Python para cálculo de área e perímetro de uma forma geométrica.
                Toda forma
                deve
                conseguir realizar ambos os cálculos; não há informação comum entre as formas. A princípio,
                serão
                implementados círculo e retângulo. Trata-se de um caso em que se torna interessante o uso de
                interfaces, já que o objetivo desejado em comum entre as classes são comportamentos, e não
                dados.
            </p>
            <img src="objetos/layout_5_fig7.png" class="img-responsive center-block">
            <p class="legenda-imagem">
                Diagrama de classes para a solução de formas geométricas <br>
                Fonte: Senac EAD (2022)
            </p>
            <p class="acessivel no-print">A imagem mostra um diagrama de classe “&lt;&lt;interface>>
                FormaGeometrica”, com
                métodos “calculaArea():float”, “calculaPerimetro():float”. Abaixo, com flecha tracejada,
                conectam-se a
                “FormaGeometrica” à classe “Circulo”, com atributo “raio:float”, e à classe “Retangulo”, com
                atributos
                “base:float” e “altura:float”.</p>
        </div>

        <p>
            Para implementar um programa em Python que calcula a área e o perímetro de formas geométricas
            (círculo e retângulo) usando interfaces, você pode seguir um padrão semelhante ao que foi
            descrito
            no exemplo em Python. No entanto, Python não tem interfaces como Python, mas você pode usar
            classes
            abstratas para definir os métodos que as classes concretas devem implementar, conforme o exemplo
            a
            seguir, em Python.
        </p>

        <pre>
            <code>
<span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 
<span class="l-python-orange">import</span> math 
           
# Classe abstrata que define a interface FormaGeometrica 
<span class="l-python-orange">class</span> FormaGeometrica(ABC): 
<span class="l-python-amarelo">@abstractmethod </span>
<span class="l-python-orange">def</span> <span class="l-python-blue">calcula_area</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
           
<span class="l-python-amarelo">@abstractmethod </span>
<span class="l-python-orange">def</span> <span class="l-python-blue">calcula_perimetro</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span>

# Classe concreta para representar um círculo 
<span class="l-python-orange">class</span> Circulo(FormaGeometrica): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, raio): 
<span class="l-python-violeta">self</span>.raio = raio 
                   
<span class="l-python-orange">def</span> <span class="l-python-blue">calcula_area</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> math.pi * <span class="l-python-violeta">self</span>.raio ** <span class="l-python-aqua">2</span> 
                   
<span class="l-python-orange">def</span> <span class="l-python-blue">calcula_perimetro</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-aqua">2</span> * math.pi * <span class="l-python-violeta">self</span>.raio 
                   
# Classe concreta para representar um retângulo 
<span class="l-python-orange">class</span> Retangulo(FormaGeometrica): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, base, altura): 
<span class="l-python-violeta">self</span>.base = base 
<span class="l-python-violeta">self</span>.altura = altura 
                   
<span class="l-python-violeta">def</span> calcula_area(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.base * <span class="l-python-violeta">self</span>.altura 
                   
<span class="l-python-orange">def</span> <span class="l-python-blue">calcula_perimetro</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-aqua">2</span> * (<span class="l-python-violeta">self</span>.base + <span class="l-python-violeta">self</span>.altura) 
                   
# Função para calcular e imprimir área e perímetro de uma forma geométrica 
<span class="l-python-orange">def</span> <span class="l-python-blue">calcular_e_imprimir</span>(forma): 
area = forma.calcula_area() 
perimetro = forma.calcula_perimetro() 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Área:</span> <span class="l-python-orange">{</span>area<span class="l-python-orange">:</span><span class="l-python-green">.2f</span><span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Perímetro:</span> <span class="l-python-orange">{</span>perimetro<span class="l-python-orange">:</span><span class="l-python-green">.2f</span><span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
                   
# Exemplo de uso 
circulo = Circulo(<span class="l-python-aqua">5.0</span>) 
retangulo = Retangulo(<span class="l-python-aqua">4.0</span>, <span class="l-python-aqua">6.0</span>) 
                   
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Círculo:"</span>) 
calcular_e_imprimir(circulo) 
                   
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"</span><span class="l-python-orange">\n</span><span class="l-python-green">Retângulo:"</span>) 
calcular_e_imprimir(retangulo)
              </code>
        </pre>

        <p>
            No exemplo, foi criada uma classe abstrata FormaGeometrica, que define a interface com os
            métodos
            calcula_area e calcula_perimetro. Em seguida, foram criadas duas classes concretas, Circulo e
            Retangulo, que herdam de FormaGeometrica e implementam os métodos de cálculo de área e perímetro
            de
            acordo com suas próprias fórmulas. A função calcular_e_imprimir aceita uma forma geométrica como
            argumento e calcula a área e o perímetro, exibindo os resultados. O exemplo de uso demonstra
            como
            criar um círculo e um retângulo e calcular suas áreas e perímetros.
        </p>
        <p>Saída do programa: </p>

        <pre>
          <code>
Círculo: 
Área: 78.54 
Perímetro: 31.42 

Retângulo: 
Área: 24.00 
Perímetro: 20.00 

Process finished with exit code 0 
          </code>
        </pre>
        
      </div>
          
      <div class="pagina">
        <div class="container">
          <h3>Múltiplas interfaces</h3>
          <p>
              Em Python, não há uma construção de linguagem que corresponda diretamente às interfaces como em
              Python. No entanto, você pode implementar múltiplas interfaces em Python de maneira diferente,
              embora não seja uma prática tão comum quanto em Python.
          </p>
          <p>
              Em Python, a implementação de múltiplas interfaces é geralmente alcançada usando herança
              múltipla.
              Você pode criar classes que herdam de várias classes (incluindo classes abstratas) para adotar
              diferentes comportamentos. Observe a seguir:
          </p>
          <pre>
              <code>
<span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

# Interface 1 
<span class="l-python-orange">class</span> Interface1(ABC): 
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange"> def</span> <span class="l-python-blue">metodo_interface1</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 

# Interface 2 
<span class="l-python-orange">class</span> Interface2(ABC): 
<span class="l-python-amarelo">@abstractmethod </span>
<span class="l-python-orange">def</span> <span class="l-python-blue">metodo_interface2</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 

# Classe que implementa ambas as interfaces 
<span class="l-python-orange">class</span> MinhaClasse(Interface1, Interface2): 
<span class="l-python-orange">def</span> <span class="l-python-blue">metodo_interface1</span>(<span class="l-python-violeta">self</span>):
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Método da Interface1 implementado"</span>) 

<span class="l-python-orange">def</span> <span class="l-python-blue">metodo_interface2</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Método da Interface2 implementado"</span>) 

# Exemplo de uso 
obj = MinhaClasse() 
obj.metodo_interface1() 
obj.metodo_interface2()
              </code>
          </pre>
          <p>
              No exemplo, foram criadas duas interfaces (Interface1 e Interface2) usando classes abstratas. Em
              seguida, foi criada uma classe MinhaClasse, que herda de ambas as interfaces. A classe
              MinhaClasse
              implementa os métodos definidos nas interfaces, permitindo que ela adote comportamentos de ambas
              as
              interfaces.
          </p>
          <p>
              No entanto, é importante notar que a herança múltipla em Python pode ser poderosa, mas também
              pode
              ser complexa e potencialmente levar a problemas de ambiguidade. Portanto, é aconselhável usá-la
              com
              cuidado e considerar alternativas, como a composição, dependendo da situação. Em muitos casos, é
              possível alcançar os mesmos resultados de maneira mais clara e segura usando composição e
              herança
              simples.
          </p>
          <p>Saída do programa:</p>
          <pre>
              <code>
Método da Interface1 implementado 
Método da Interface2 implementado 

Process finished with exit code 0 
              </code>
          </pre>
          <p>
              Nesse exemplo, o objetivo será criar duas interfaces diferentes: “Query” e “Command”, que são
              dois
              conceitos da programação, sendo “Query” para representar operações de leitura e “Command” para
              representar operações de mutação (inserir, alterar ou remover). Dessa forma, é possível
              identificar
              que a interface “DAO” pode ser dividida em duas interfaces, uma “Query” e uma “Command”. A
              interface
              “Query” especificará todas as funções de leitura, enquanto a interface “Command” especificará as
              funções de mutação.
          </p>
          <div class="caixa-destaque icone anotar">
              <p>
                  Os conceitos DAO, Query e Command são amplamente utilizados em projetos de <i>software</i>.
                  Os três
                  fazem parte do mesmo princípio de qualidade de <i>software</i>, chamado “separação de
                  responsabilidades”. Você aprenderá mais sobre isso em breve.
              </p>
          </div>
          <p>
              Será criado um exemplo em Python que define duas interfaces, “Query” e “Command”, para
              representar
              operações de leitura e mutação, respectivamente. Em seguida, será criada uma classe “DAO”, que
              implementará ambas as interfaces.
          </p>
          <p>Seguindo esse novo exemplo, veja o código a seguir:</p>
          <pre>
              <code>
<span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

# Interface para operações de leitura 
<span class="l-python-orange">class</span> Query(ABC): 
<span class="l-python-amarelo">@abstractmethod </span>
<span class="l-python-orange">def</span> <span class="l-python-blue">ler_dados</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 

# Interface para operações de mutação 
<span class="l-python-orange">class</span> Command(ABC): 
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">inserir_dados</span>(<span class="l-python-violeta">self</span>, dados): 
<span class="l-python-orange">pass</span> 

<span class="l-python-amarelo">@abstractmethod </span>
<span class="l-python-orange">def</span> <span class="l-python-blue">alterar_dados</span>(<span class="l-python-violeta">self</span>, dados): 
<span class="l-python-orange">pass </span>

<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">remover_dados</span>(<span class="l-python-violeta">self</span>, id): 
<span class="l-python-orange">pass</span> 

# Classe DAO que implementa ambas as interfaces 
<span class="l-python-orange">class</span> DAO(Query, Command): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-violeta">self</span>.data = {} 

<span class="l-python-orange">def</span> <span class="l-python-blue">ler_dados</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.data 

<span class="l-python-orange">def</span> <span class="l-python-blue">inserir_dados</span>(<span class="l-python-violeta">self</span>, dados): 
<span class="l-python-violeta">self</span>.data[dados[<span class="l-python-green">'id'</span>]] = dados 

<span class="l-python-orange">def</span> <span class="l-python-blue">alterar_dados</span>(<span class="l-python-violeta">self</span>, dados): 
<span class="l-python-orange">if</span> dados[<span class="l-python-green">'id'</span>] <span class="l-python-orange">in</span> <span class="l-python-violeta">self</span>.data: 
  <span class="l-python-violeta">self</span>.data[dados[<span class="l-python-green">'id'</span>]] = dados 

<span class="l-python-orange">def</span> <span class="l-python-blue">remover_dados</span>(<span class="l-python-violeta">self</span>, id):
<span class="l-python-orange">if</span> id <span class="l-python-orange">in</span> <span class="l-python-violeta">self</span>.data: 
  <span class="l-python-orange">del</span> <span class="l-python-violeta">self</span>.data[id] 

# Exemplo de uso 
dao = DAO() 

# Operações de mutação 
dao.inserir_dados({<span class="l-python-green">'id'</span>: <span class="l-python-aqua">1</span>, <span class="l-python-green">'nome'</span>: <span class="l-python-green">'Alice'</span>}) 
dao.inserir_dados({<span class="l-python-green">'id'</span>: <span class="l-python-aqua">2</span>, <span class="l-python-green">'nome'</span>: <span class="l-python-green">'Bob'</span>}) 

# Operações de leitura 
dados = dao.ler_dados() 
<span class="l-python-aescuro">print</span>(dados) 

# Alterar dados 
dao.alterar_dados({<span class="l-python-green">'id'</span>: <span class="l-python-aqua">1</span>, <span class="l-python-green">'nome'</span>: <span class="l-python-green">'Alicia'</span>}) 
dados = dao.ler_dados() 
<span class="l-python-aescuro">print</span>(dados) 

# Remover dados 
dao.remover_dados(<span class="l-python-aqua">2</span>) 
dados = dao.ler_dados() 
<span class="l-python-aescuro">print</span>(dados)
      </code>
          </pre>
          <p>
              Foram criadas duas interfaces, “Query” e “Command”, que definem métodos para operações de
              leitura e
              mutação, respectivamente. Em seguida, a classe “DAO” implementa ambas as interfaces e fornece
              implementações concretas para os métodos. Esse exemplo de uso demonstra como a classe “DAO” pode
              ser
              usada para realizar operações de mutação (inserir, alterar, remover) e operações de leitura.
              Separar
              as operações de leitura e mutação em interfaces distintas facilita a organização e a manutenção
              do
              código.
          </p>
          <p> Saída do programa:</p>
          <pre>
              <code>
{1: {'id': 1, 'nome': 'Alice'}, 2: {'id': 2, 'nome': 'Bob'}} 
{1: {'id': 1, 'nome': 'Alicia'}, 2: {'id': 2, 'nome': 'Bob'}} 
{1: {'id': 1, 'nome': 'Alicia'}} 

Process finished with exit code 0 
              </code>
          </pre>
          <div class="caixa-destaque icone desafio">
              <p>
                  Crie um programa orientado a objeto que implemente pelo menos três partes diferentes de um
                  carro, por exemplo, motor, janelas e rádio. Para cada funcionalidade, apenas imprima uma
                  linha descrevendo a ação que está sendo realizada. Utilize interfaces para concluir esse
                  desafio.
              </p>
              <button type="button" class="botao bg-primaria-03 texto-primaria-02 mt-60 centralizar no-print"
                  data-toggle="modal" data-target="#modal-desafio2">Gabarito</button>

              <div class="modal modal-100 fade" id="modal-desafio2" aria-hidden="true">
                  <div class="modal-dialog">
                      <div class="modal-content no-print">
                          <div class="modal-header" style="padding-top: 30px;">
                              <button type="button" class="close" data-dismiss="modal"
                                  aria-label="Close"><span aria-hidden="true">×</span></button>
                              <h3 class="modal-title">
                                  <div class="container">GABARITO DO DESAFIO</div>
                              </h3>
                          </div>
                          <div class="modal-body">
                              <div class="container">
                                  <p>
                                      Programa em Python que implementa três partes diferentes de um carro, o
                                      motor, as janelas e o rádio, usando interfaces. Cada parte terá um
                                      método que descreve uma ação específica relacionada a essa parte do
                                      carro.
                                  </p>
                                  <pre>
                                      <code>
<span class="l-python-orange">from</span> abc <span class="l-python-orange">import</span> ABC, abstractmethod 

# Interface para a parte do carro - Motor 
<span class="l-python-orange">class</span> Motor(ABC): 
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">ligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
                                           
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">desligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
                                           
# Interface para a parte do carro - Janelas 
<span class="l-python-orange">class</span> Janelas(ABC): 
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">abrir</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
                                           
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">fechar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
                                           
# Interface para a parte do carro - Rádio 
<span class="l-python-orange">class</span> Radio(ABC): 
<span class="l-python-amarelo">@abstractmethod </span>
<span class="l-python-orange">def</span> <span class="l-python-blue">ligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
                                           
<span class="l-python-amarelo">@abstractmethod</span> 
<span class="l-python-orange"> def</span> <span class="l-python-blue">desligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">pass</span> 
                                           
# Classe que implementa a parte do carro - Motor 
<span class="l-python-orange">class</span> CarroMotor(Motor): 
<span class="l-python-orange">def</span> <span class="l-python-blue">ligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Motor ligado"</span>) 

<span class="l-python-orange">def</span> <span class="l-python-blue">desligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">class</span> CarroJanelas(Janelas): 
<span class="l-python-orange">def</span><span class="l-python-blue"> abrir</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Janelas abertas"</span>) 

<span class="l-python-orange">def</span> <span class="l-python-blue">fechar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Janelas fechadas"</span>) 

# Classe que implementa a parte do carro - Rádio 
<span class="l-python-orange">class</span> CarroRadio(Radio): 
<span class="l-python-orange">def</span> <span class="l-python-blue">ligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Rádio ligado"</span>) 

<span class="l-python-orange">def</span> <span class="l-python-blue">desligar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Rádio desligado"</span>) 

# Exemplo de uso 
carro = CarroMotor() 
carro.ligar() 

carro_janelas = CarroJanelas() 
carro_janelas.abrir() 

carro_radio = CarroRadio() 
carro_radio.ligar() 
                                      </code>
                                  </pre>
                                  <p>
                                      Nesse exemplo, foram definidas três interfaces, cada uma representando
                                      uma
                                      parte diferente de um carro: “Motor”, “Janelas” e “Rádio”. Em seguida,
                                      foram
                                      criadas classes concretas que implementam essas interfaces e fornecem
                                      implementações para os métodos específicos de cada parte do carro.
                                  </p>
                                  <p>
                                      Foi criada uma instância da classe “CarroMotor” e chamado o método
                                      “ligar”
                                      para ligar o motor. Em seguida, foi criada uma instância da classe
                                      “CarroJanelas” e chamado o método “abrir” para abrir as janelas. Por
                                      fim,
                                      foi criada uma instância da classe “CarroRadio” e chamado o método
                                      “ligar”
                                      para ligar o rádio.
                                  </p>
                                  <p>
                                      Cada parte do carro tem seu próprio conjunto de ações específicas, e as
                                      interfaces facilitam a implementação e a organização dessas
                                      funcionalidades.
                                  </p>
                                  <div class="modal-footer">
                                      <button type="button" class="btn btn-default"
                                          data-dismiss="modal">Fechar</button>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
          <p>
              Agora você já sabe as diferenças entre classes abstratas e interfaces e como utilizá-las.
              Conheça
              algumas estratégias e técnicas usadas em projetos de <i>software</i> que requerem o uso de abstrações
              para
              funcionar.
          </p>
          <div class="caixa-destaque icone anotar">
              <p>
                  Em Python, não há uma anotação direta equivalente ao <b>@Override</b> em Python. Em Python,
                  a anotação
                  <b>@Override</b> é usada para indicar explicitamente que um método na classe filha está
                  sobrescrevendo
                  um método na classe pai.
              </p>
              <p>
                  Em Python, a sobreposição de métodos (<i>override</i>) é alcançada simplesmente definindo um método
                  na
                  classe filha com o mesmo nome que o método na classe pai. Python não requer uma anotação
                  especial para indicar a sobreposição. Se você definir um método com o mesmo nome na classe
                  filha, ele automaticamente substituirá o método na classe pai.
              </p>
              <p>Vejo o exemplo de sobreposição de método em Python:</p>
              <pre>
                  <code>
<span class="l-python-orange">class</span> Animal: 
<span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Animal faz algum som"</span>) 

<span class="l-python-orange">class</span> Cachorro(Animal): 
<span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Cachorro faz latido"</span>) 

# Exemplo de uso 
animal = Animal() 
animal.fazer_som()  # Saída: Animal faz algum som 

cachorro = Cachorro() 
cachorro.fazer_som()  # Saída: Cachorro faz latido 
                  </code>
              </pre>
              <p>
                  No exemplo, a classe <b>Cachorro</b> herda da classe <b>Animal</b> e sobrescreve o método
                  <b>fazer_som</b> para
                  fornecer uma implementação específica para cachorros. Não é necessário usar @<b>Override</b>
                  em Python
                  para indicar a sobreposição; a simples definição do método na classe filha é suficiente.
              </p>
              <p>Saída do programa: </p>
              <pre>
                  <code>
Animal faz algum som 
Cachorro faz latido 

Process finished with exit code 0 
                  </code>
              </pre>
          </div>
          
        </div>       
      </div>

      <div class="pagina">
        <h3>Polimorfismo</h3>
        <p>Na programação orientada a objetos, polimorfismo é o conceito no qual você pode alcançar comportamentos
          diferentes por meio da mesma interface. Seguindo o significado da palavra "polimorfo", um método ou uma classe
          polimorfa é uma classe que pode se passar por outras, adotando diferentes comportamentos dependendo do seu
          contexto. Uma forma prática de entender esse conceito é imaginar que um mesmo método pode ter diferentes
          versões.</p>

        <p>Existem duas formas principais para implementar o conceito de polimorfismo: polimorfismo estático e
          polimorfismo dinâmico. Conheça um pouco mais sobre cada um:</p>

        <div class="no-print" aria-hidden="true">
          <p>Clique ou toque para visualizar o conteúdo.</p>
          <div class="row">
              <div class="col-md-6 col-sm-6 col-xs-12">
                  <button type="button" class="btn-polimorfismo btn-polimorfismo01 center-block"
                      data-toggle="modal" data-target="#modal-polimorfismo01"></button>
              </div>
              <div class="col-md-6 col-sm-6 col-xs-12">
                  <button type="button" class="btn-polimorfismo btn-polimorfismo02 center-block"
                      data-toggle="modal" data-target="#modal-polimorfismo02"></button>
              </div>
          </div>
        </div>


        <div class="modal fade" id="modal-polimorfismo01" tabindex="-1" role="dialog"
        aria-labelledby="myModalLabel">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                            aria-hidden="true">×</span></button>
                    <h4 class="modal-title" id="myModalLabel">Polimorfismo estático</h4>
                </div>
                <div class="modal-body">
                    <p>
                        Seguindo o conceito de polimorfismo, o <b>polimorfismo estático</b> é uma forma
                        de
                        adicionar diferentes comportamentos para o mesmo método. O fato deste ser
                        estático
                        significa que o compilador consegue determinar qual comportamento/versão será
                        executado.
                    </p>
                    <p>
                        Python não permite que você defina métodos com o mesmo nome e parâmetros
                        diferentes
                        diretamente no nível da classe. Para contornar essa limitação em Python e ter
                        métodos
                        com nomes idênticos e números diferentes de parâmetros, você pode usar
                        argumentos
                        padrão e delegação de chamada para implementar a lógica desejada. Aqui está um
                        exemplo revisado:
                    </p>
                    <p> Exemplo de polimorfismo estático em Python: </p>
                    <pre>
                        <code>
<span class="l-python-orange">class</span> Calculadora: 
<span class="l-python-orange">def</span> <span class="l-python-blue">soma</span>(<span class="l-python-violeta">self</span>, a, b, c=<span class="l-python-orange">None</span>): 
<span class="l-python-orange">if</span> c <span class="l-python-orange">is not None</span>: 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>._soma_tres_numeros(a, b, c) 
<span class="l-python-orange"> return</span> <span class="l-python-violeta">self</span>._soma_dois_numeros(a, b) 

<span class="l-python-orange">def</span><span class="l-python-blue"> _soma_dois_numeros</span>(<span class="l-python-violeta">self</span>, a, b): 
<span class="l-python-orange">return</span> a + b 

<span class="l-python-orange">def</span> <span class="l-python-blue">_soma_tres_numeros</span>(<span class="l-python-violeta">self</span>, a, b, c): 
<span class="l-python-orange"> return</span> a + b + c 

calc = Calculadora() 
result1 = calc.soma(<span class="l-python-aqua">2</span>, <span class="l-python-aqua">3</span>)  # Chama o método com dois parâmetros 
<span class="l-python-aescuro">print</span> (<span class="l-python-green">" 2 + 3 = "</span>, result1) 
result2 = calc.soma(<span class="l-python-aqua">2</span>, <span class="l-python-aqua">3</span>, <span class="l-python-aqua">4</span>)  # Chama o método com três parâmetros 
print (<span class="l-python-green">" 2 + 3 + 4= "</span>, result2) 
                        </code>
                    </pre>
                    <p>
                        Neste exemplo, os métodos _soma_dois_numeros e _soma_tres_numeros realizam a
                        lógica
                        de soma de dois e três números, respectivamente. O método soma principal
                        direciona a
                        chamada para um desses métodos com base no número de argumentos fornecidos. Isso
                        permite que você tenha métodos com nomes idênticos e números diferentes de
                        parâmetros na classe Calculadora.
                    </p>
                    <p> Saída do programa:</p>
                    <pre>
                        <code>
2 + 3 =  5 
2 + 3 + 4=  9 

Process finished with exit code 0 
                        </code>
                    </pre>
                    <div class="caixa-destaque icone anotar">
                        <p>
                            Veremos mais adiante que existe outro tipo de Polimorfismo, onde só é
                            possível
                            validar qual comportamento/versão será executado em tempo de execução (isto
                            é,
                            executando o código-fonte).
                        </p>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal">Fechar</button>
                </div>
            </div>
        </div>
        </div>

        <div class="modal fade" id="modal-polimorfismo02" tabindex="-1" role="dialog"
            aria-labelledby="myModalLabel">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                                aria-hidden="true">×</span></button>
                        <h4 class="modal-title" id="myModalLabel">Polimorfismo dinâmico</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            Como dito anteriormente, existe outro tipo de polimorfismo, no qual só é
                            possível
                            validar qual comportamento/versão será executado em tempo de execução (isto é,
                            executando o código-fonte). Esse formato de polimorfismo é conhecido como
                            polimorfismo dinâmico.
                        </p>
                        <p>
                            Como ele, o compilador não consegue determinar a versão/comportamento que será
                            executada de um método ou classe polimorfa. Nesse cenário, a diferença existe
                            apenas
                            no tempo de execução, ou seja, é um cenário muito comum e utilizado em alguns
                            conceitos de boas práticas, que serão estudados futuramente, como na injeção de
                            dependências.
                        </p>
                        <p>O polimorfismo dinâmico também é conhecido como:</p>
                        <ul>
                            <li>Polimorfismo em tempo de execução (do inglês run-time polymorphism)</li>
                            <li>Ligação dinâmica (dynamic binding) </li>
                            <li>Ligação em tempo de execução (run-time binding) </li>
                            <li>Ligação tardia (late binding) </li>
                            <li>Sobreposição de método (method overriding) </li>
                        </ul>
                        <p>
                            Para o polimorfismo dinâmico funcionar, suponha que existam diferentes métodos
                            com a
                            mesma assinatura (isto é, métodos que recebem os mesmos argumentos e retornam o
                            mesmo tipo de dado), sendo cada método em uma classe diferente. Para
                            caracterizar o
                            polimorfismo dinâmico, cada classe deverá (1) herdar da mesma superclasse ou (2)
                            implementar a mesma interface ou classe abstrata.
                        </p>
                        <p>
                            Assim como no polimorfismo estático, existem diversas técnicas para atingir o
                            objetivo do polimorfismo dinâmico, dependendo dos recursos providos pela
                            linguagem
                            de programação em uso. No Java, é muito comum a utilização da técnica de
                            sobreposição de método. Para exemplificar um cenário, observe a imagem a seguir.
                        </p>
                        <img src="objetos/layout_5_fig8_ilustra_falas.png"
                            class="img-responsive center-block">
                        <p class="legenda-imagem">
                            Exemplo de polimorfismo com a ação “Falar” <br>
                            Fonte:&lt;https://medium.com/@shanikae/polymorphism-explained-simply-7294c8deeef7>.
                            Acesso em: 03 abr. 2022.
                        </p>
                        <p class="acessivel no-print">A imagem contém um homem falando "Agora falem!" para
                            um cachorro, um pato e um
                            gato. O cachorro está respondendo "Au-au", o pato está respondendo "Quac" e o
                            gato está respondendo
                            "Miau".
                        </p>
                        <p>
                            Essa figura é um exemplo de “sobreposição de método”, uma estratégia para
                            alcançar o
                            “polimorfismo dinâmico”. Há três animais diferentes: um cachorro, um pato e um
                            gato.
                            Os três são capazes de se comunicar (no programa, esse método é chamado de
                            “falar”),
                            porém cada animal se comunica de uma forma diferente.
                        </p>
                        <pre>
                            <code>
    <span class="l-python-orange">class</span> Animal: 
    <span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
    <span class="l-python-orange"> pass </span>

    <span class="l-python-orange">class</span> Cachorro(Animal): 
    <span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
    <span class="l-python-orange">return</span> <span class="l-python-green">"Au au"</span> 

    <span class="l-python-orange">class</span> Gato(Animal): 
    <span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
    <span class="l-python-orange">return</span><span class="l-python-green"> "Miau"</span> 

    <span class="l-python-orange">class</span> Pato(Animal): 
    <span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
    <span class="l-python-orange">return</span> <span class="l-python-green">"Quack"</span> 
    <span class="l-python-orange">def</span> <span class="l-python-blue">som_do_animal</span>(animal): 
    <span class="l-python-orange">return</span> animal.fazer_som() 

    cachorro = Cachorro() 
    gato = Gato() 
    pato = Pato() 

    <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Cachorro: "</span>, som_do_animal(cachorro))  # Chama o fazer_som de Cachorro 
    <span class="l-python-aescuro"> print</span>(<span class="l-python-green">"Gato: "</span>,som_do_animal(gato))      # Chama o fazer_som de Gato 
    <span class="l-python-aescuro"> print</span>(<span class="l-python-green">"pato: "</span>,som_do_animal(pato))
                            </code>
                        </pre>
                        <p>
                            Nesse programa, temos a classe-base Animal com um método fazer_som e duas
                            classes
                            derivadas, Cachorro e Gato, que substituem o método fazer_som. A função
                            som_do_animal permite que objetos de diferentes classes respondam de maneira
                            diferente ao método fazer_som, com base no tipo real do objeto. Isso demonstra o
                            polimorfismo dinâmico.
                        </p>
                        <p>Saída do programa:</p>
                        <pre>
                        <code>                                         
    Cahorro:  Au au 
    Gato:  Miau 
    pato:  Quack 

    Process finished with exit code 0 
                        </code>
                      </pre>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-default" data-dismiss="modal">Fechar</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="acessivel print">
          
          <h4>Polimorfismo estático</h4>      
          <p>
              Seguindo o conceito de polimorfismo, o <b>polimorfismo estático</b> é uma forma
              de
              adicionar diferentes comportamentos para o mesmo método. O fato deste ser
              estático
              significa que o compilador consegue determinar qual comportamento/versão será
              executado.
          </p>
          <p>
              Python não permite que você defina métodos com o mesmo nome e parâmetros
              diferentes
              diretamente no nível da classe. Para contornar essa limitação em Python e ter
              métodos
              com nomes idênticos e números diferentes de parâmetros, você pode usar
              argumentos
              padrão e delegação de chamada para implementar a lógica desejada. Aqui está um
              exemplo revisado:
          </p>
          <p> Exemplo de polimorfismo estático em Python: </p>
            
          <pre>
              <code>
<span class="l-python-orange">class</span> Calculadora: 
<span class="l-python-orange">def</span> <span class="l-python-blue">soma</span>(<span class="l-python-violeta">self</span>, a, b, c=<span class="l-python-orange">None</span>): 
<span class="l-python-orange">if</span> c <span class="l-python-orange">is not None</span>: 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>._soma_tres_numeros(a, b, c) 
<span class="l-python-orange"> return</span> <span class="l-python-violeta">self</span>._soma_dois_numeros(a, b) 

<span class="l-python-orange">def</span><span class="l-python-blue"> _soma_dois_numeros</span>(<span class="l-python-violeta">self</span>, a, b): 
<span class="l-python-orange">return</span> a + b 

<span class="l-python-orange">def</span> <span class="l-python-blue">_soma_tres_numeros</span>(<span class="l-python-violeta">self</span>, a, b, c): 
<span class="l-python-orange"> return</span> a + b + c 

calc = Calculadora() 
result1 = calc.soma(<span class="l-python-aqua">2</span>, <span class="l-python-aqua">3</span>)  # Chama o método com dois parâmetros 
<span class="l-python-aescuro">print</span> (<span class="l-python-green">" 2 + 3 = "</span>, result1) 
result2 = calc.soma(<span class="l-python-aqua">2</span>, <span class="l-python-aqua">3</span>, <span class="l-python-aqua">4</span>)  # Chama o método com três parâmetros 
print (<span class="l-python-green">" 2 + 3 + 4= "</span>, result2) 
                        </code>
          </pre>
          <p>
              Neste exemplo, os métodos _soma_dois_numeros e _soma_tres_numeros realizam a
              lógica
              de soma de dois e três números, respectivamente. O método soma principal
              direciona a
              chamada para um desses métodos com base no número de argumentos fornecidos. Isso
              permite que você tenha métodos com nomes idênticos e números diferentes de
              parâmetros na classe Calculadora.
          </p>
          <p> Saída do programa:</p>
          <pre>
              <code>
  2 + 3 =  5 
  2 + 3 + 4=  9 
  
  Process finished with exit code 0 
                </code>
          </pre>
          <div class="caixa-destaque icone anotar">
            <p>
                Veremos mais adiante que existe outro tipo de Polimorfismo, onde só é
                possível
                validar qual comportamento/versão será executado em tempo de execução (isto
                é,
                executando o código-fonte).
            </p>
          </div>
                         
          <h4>Polimorfismo dinâmico</h4>
          <p>
              Como dito anteriormente, existe outro tipo de polimorfismo, no qual só é
              possível
              validar qual comportamento/versão será executado em tempo de execução (isto é,
              executando o código-fonte). Esse formato de polimorfismo é conhecido como
              polimorfismo dinâmico.
          </p>
          <p>
              Como ele, o compilador não consegue determinar a versão/comportamento que será
              executada de um método ou classe polimorfa. Nesse cenário, a diferença existe
              apenas
              no tempo de execução, ou seja, é um cenário muito comum e utilizado em alguns
              conceitos de boas práticas, que serão estudados futuramente, como na injeção de
              dependências.
          </p>
          <p>O polimorfismo dinâmico também é conhecido como:</p>
          <ul>
              <li>Polimorfismo em tempo de execução (do inglês run-time polymorphism)</li>
              <li>Ligação dinâmica (dynamic binding) </li>
              <li>Ligação em tempo de execução (run-time binding) </li>
              <li>Ligação tardia (late binding) </li>
              <li>Sobreposição de método (method overriding) </li>
          </ul>
          <p>
              Para o polimorfismo dinâmico funcionar, suponha que existam diferentes métodos
              com a
              mesma assinatura (isto é, métodos que recebem os mesmos argumentos e retornam o
              mesmo tipo de dado), sendo cada método em uma classe diferente. Para
              caracterizar o
              polimorfismo dinâmico, cada classe deverá (1) herdar da mesma superclasse ou (2)
              implementar a mesma interface ou classe abstrata.
          </p>
          <p>
              Assim como no polimorfismo estático, existem diversas técnicas para atingir o
              objetivo do polimorfismo dinâmico, dependendo dos recursos providos pela
              linguagem
              de programação em uso. No Java, é muito comum a utilização da técnica de
              sobreposição de método. Para exemplificar um cenário, observe a imagem a seguir.
          </p>
          <img src="objetos/layout_5_fig8_ilustra_falas.png"
              class="img-responsive center-block">
          <p class="legenda-imagem">
              Exemplo de polimorfismo com a ação “Falar” <br>
              Fonte:&lt;https://medium.com/@shanikae/polymorphism-explained-simply-7294c8deeef7>.
              Acesso em: 03 abr. 2022.
          </p>
          <p class="acessivel no-print">A imagem contém um homem falando "Agora falem!" para
              um cachorro, um pato e um
              gato. O cachorro está respondendo "Au-au", o pato está respondendo "Quac" e o
              gato está respondendo
              "Miau".
          </p>
          <p>
              Essa figura é um exemplo de “sobreposição de método”, uma estratégia para
              alcançar o
              “polimorfismo dinâmico”. Há três animais diferentes: um cachorro, um pato e um
              gato.
              Os três são capazes de se comunicar (no programa, esse método é chamado de
              “falar”),
              porém cada animal se comunica de uma forma diferente.
          </p>
          <pre>
              <code>
<span class="l-python-orange">class</span> Animal: 
<span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange"> pass </span>

<span class="l-python-orange">class</span> Cachorro(Animal): 
<span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-green">"Au au"</span> 

<span class="l-python-orange">class</span> Gato(Animal): 
<span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span><span class="l-python-green"> "Miau"</span> 

<span class="l-python-orange">class</span> Pato(Animal): 
<span class="l-python-orange">def</span> <span class="l-python-blue">fazer_som</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-green">"Quack"</span> 
<span class="l-python-orange">def</span> <span class="l-python-blue">som_do_animal</span>(animal): 
<span class="l-python-orange">return</span> animal.fazer_som() 

cachorro = Cachorro() 
gato = Gato() 
pato = Pato() 

<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Cachorro: "</span>, som_do_animal(cachorro))  # Chama o fazer_som de Cachorro 
<span class="l-python-aescuro"> print</span>(<span class="l-python-green">"Gato: "</span>,som_do_animal(gato))      # Chama o fazer_som de Gato 
<span class="l-python-aescuro"> print</span>(<span class="l-python-green">"pato: "</span>,som_do_animal(pato))
              </code>
          </pre>
          <p>
              Nesse programa, temos a classe-base Animal com um método fazer_som e duas
              classes
              derivadas, Cachorro e Gato, que substituem o método fazer_som. A função
              som_do_animal permite que objetos de diferentes classes respondam de maneira
              diferente ao método fazer_som, com base no tipo real do objeto. Isso demonstra o
              polimorfismo dinâmico.
          </p>
          <p>Saída do programa:</p>
          <pre>
            <code>                                         
Cahorro:  Au au 
Gato:  Miau 
pato:  Quack 

Process finished with exit code 0 
            </code>
          </pre>
                      
        </div>

        <div class="caixa-destaque-livre bg-primaria-02 borda-primaria-03">
          <p>
              <b>Exemplo 5</b>: retomando o exemplo 2 em que fizemos classes para um serviço de streaming,
              temos a
              classe base Video e as classes derivadas Filme e Episodio. Vemos que o método tocar() está
              presente apenas na superclasse, mas seria adequado que tivessem implementações também em
              Filme e
              Episodio, já que essas classes possuem atributos próprios. Vamos usar polimorfismo para
              isso.
          </p>
          <p>
              Para implementar o polimorfismo nos métodos tocar() das classes Filme e Episodio, você pode
              criar versões personalizadas desses métodos em cada uma das subclasses, mantendo a
              assinatura do
              método consistente com o da superclasse Video.
          </p>
          <p>Observe a implementação do polimorfismo nos métodos tocar() das classes Filme e Episodio:</p>
          <pre>
              <code>
<span class="l-python-orange">class</span> Video: 
<span class="l-python-orange"> def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, titulo, ano, diretor, duracao): 
<span class="l-python-violeta">self</span>.titulo = titulo 
<span class="l-python-violeta">self</span>.ano = ano 
<span class="l-python-violeta">self</span>.diretor = diretor 
<span class="l-python-violeta">self</span>.duracao = duracao 

<span class="l-python-orange">def</span> <span class="l-python-blue">tocar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-green">f"Tocando</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.titulo<span class="l-python-orange">}</span><span class="l-python-green">"</span> 
               
<span class="l-python-orange">class</span> Filme(Video): 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, titulo, ano, diretor, duracao, genero, produtora): 
<span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(titulo, ano, diretor, duracao) 
<span class="l-python-violeta">self</span>.genero = genero 
<span class="l-python-violeta">self</span>.produtora = produtora 

<span class="l-python-orange">def</span> <span class="l-python-blue">tocar</span>(<span class="l-python-violeta">self</span>): 
<span class="bg-amarelo "> # Alteração: Personalização do método tocar() para a classe Filme </span>
<span class="l-python-orange">return</span> <span class="l-python-green">f"Tocando o filme '</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span class="l-python-violeta">.titulo<span class="l-python-orange">}</span><span class="l-python-green">'"</span>  # Mensagem específica para filmes 

<span class="l-python-orange">class</span> Episodio(Video): 
<span class="l-python-orange">def</span><span class="l-python-roxo"> __init__</span>(<span class="l-python-violeta">self</span>, titulo, ano, diretor, duracao, episodio, temporada): 
<span class="l-python-aescuro">super</span>().<span class="l-python-roxo">__init__</span>(titulo, ano, diretor, duracao) 
<span class="l-python-violeta">self</span>.episodio = episodio 
<span class="l-python-violeta">self</span>.temporada = temporada 

<span class="l-python-orange">def</span> <span class="l-python-blue">tocar</span>(<span class="l-python-violeta">self</span>): 
<span class="bg-amarelo"># Alteração: Personalização do método tocar() para a classe Episodio </span>
<span class="l-python-orange">return</span> <span class="l-python-green">f"Tocando o episódio</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.episodio<span class="l-python-orange">}</span> <span class="l-python-green">da temporada</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.temporada<span class="l-python-orange">}</span> <span class="l-python-green">de '</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.titulo<span class="l-python-orange">}</span><span class="l-python-green">'"</span>  # Mensagem específica para episódios 

# Exemplo de uso 
filme = Filme(<span class="l-python-green">"Aventuras nos Alpes"</span>, <span class="l-python-aqua">2000</span>, <span class="l-python-green">"Joana da Silva"</span>, <span class="l-python-aqua">120</span>, <span class="l-python-green">"Aventura"</span>, <span class="l-python-green">"Sun Films"</span>) 
episodio = Episodio(<span class="l-python-green">"Tecnologias Perigosas"</span>, <span class="l-python-aqua">2021</span>, <span class="l-python-green">"Joaquim da Silva"</span>, <span class="l-python-aqua">45</span>, <span class="l-python-aqua">5</span>, <span class="l-python-aqua">1</span>) 

<span class="l-python-aescuro">print</span>(filme.tocar())  # Chama o método tocar() personalizado de Filme 
<span class="l-python-aescuro">print</span>(episodio.tocar())  # Chama o método tocar() personalizado de Episodio 
              </code>
          </pre>
          <p>
              Nesse exemplo, cada classe Filme e Episodio tem uma versão personalizada do método tocar(),
              que
              retorna mensagens específicas para cada tipo de vídeo. Isso demonstra o polimorfismo, em que
              o
              método a ser chamado é decidido em tempo de execução, com base no tipo real do objeto.
          </p>
          <p>Saída do programa:</p>
          <pre>
              <code>
Tocando o filme 'Aventuras nos Alpes' 
Tocando o episódio 5 da temporada 1 de 'Tecnologias Perigosas' 

Process finished with exit code 0 
              </code>
          </pre>
        </div>

        <div class="caixa-destaque icone desafio">
          <p>
              Crie um programa para conversão de medidas. Crie uma classe “Medida” com métodos
              “converterDeMetro”
              e “converterParaMetro”; ambas retornarão o mesmo valor informado pelo usuário, já que já
              estão em
              metros. Crie classes derivadas “Polegada”, “Pé” e “Milha” que implementem versões de
              “converterDeMetro” (recebendo por parâmetro o valor em metros e retornando na medida
              correspondente
              à classe) e “converterParaMetro” (recebendo um valor na medida correspondente à classe e
              retornando
              em metros). Esses métodos retornarão valores calculados de acordo com os dados a seguir:
          </p>
          <ul>
              <li>1 polegada = 0,0254 metro </li>
              <li>1 pé = 0,3048 metro </li>
              <li>1 milha = 1609,34 metros </li>
          </ul>
        </div>

          <button type="button" class="botao bg-primaria-03 texto-primaria-02 mt-60 centralizar no-print"
              data-toggle="modal" data-target="#modal-desafio3">Gabarito</button>

          <div class="modal modal-100 fade" id="modal-desafio3" aria-hidden="true">
              <div class="modal-dialog">
                  <div class="modal-content no-print">
                      <div class="modal-header" style="padding-top: 30px;">
                          <button type="button" class="close" data-dismiss="modal"
                              aria-label="Close"><span aria-hidden="true">×</span></button>
                          <h3 class="modal-title">
                              <div class="container">GABARITO DO DESAFIO</div>
                          </h3>
                      </div>
                      <div class="modal-body">
                          <div class="container">
                              <p> Aqui está uma implementação do desafio de conversão de medidas em
                                  Python: </p>
                              <pre>
                                  <code>
<span class="l-python-orange">class</span> Medida: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, valor): 
<span class="l-python-violeta">self</span>.valor = valor 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange">return</span> valor_em_metros 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_na_medida): 
<span class="l-python-orange">return</span> valor_na_medida 

<span class="l-python-orange">class</span> Polegada(Medida): 
<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange">return</span> valor_em_metros / <span class="l-python-aqua">0.0254</span> 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_na_polegada): 
<span class="l-python-orange">return</span> valor_na_polegada * <span class="l-python-aqua">0.0254</span> 

<span class="l-python-orange">class</span> Pe(Medida): 
<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange"> return</span> valor_em_metros / <span class="l-python-aqua">0.3048</span> 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_no_pe): 
<span class="l-python-orange">return</span> valor_no_pe * <span class="l-python-aqua">0.3048</span> 

<span class="l-python-orange">class</span> Milha(Medida): 
<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange">return</span> valor_em_metros / <span class="l-python-aqua">1609.34</span> 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_na_milha): 
<span class="l-python-orange">return</span> valor_na_milha * <span class="l-python-aqua">1609.34</span> 

# Exemplo de uso 
valor_em_metros = <span class="l-python-aqua">10.0</span> 

polegada = Polegada(valor_em_metros) 
valor_na_polegada = polegada.converterDeMetro(valor_em_metros) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_em_metros<span class="l-python-orange">}</span><span class="l-python-green"> metros = </span><span class="l-python-orange">{</span>valor_na_polegada<span class="l-python-orange">}</span> <span class="l-python-green">polegadas"</span>) 
valor_de_volta = polegada.converterParaMetro(valor_na_polegada) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_na_polegada<span class="l-python-orange">}</span> <span class="l-python-green">polegadas =</span> <span class="l-python-orange">{</span>valor_de_volta<span class="l-python-orange">}</span> <span class="l-python-green">metros"</span>) 

pe = Pe(valor_em_metros) 
valor_no_pe = pe.converterDeMetro(valor_em_metros) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_em_metros<span class="l-python-orange">}</span> <span class="l-python-green">metros =</span> <span class="l-python-orange">{</span>valor_no_pe<span class="l-python-orange">}</span> <span class="l-python-green">pés"</span>) 
valor_de_volta = pe.converterParaMetro(valor_no_pe) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_no_pe<span class="l-python-orange">}</span> <span class="l-python-green">pés =</span> <span class="l-python-orange">{</span>valor_de_volta<span class="l-python-orange">}</span> <span class="l-python-green">metros"</span>)

milha = Milha(valor_em_metros) 
valor_na_milha = milha.converterDeMetro(valor_em_metros) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_em_metros<span class="l-python-orange">}</span> <span class="l-python-green">metros =</span> <span class="l-python-orange">{</span>valor_na_milha<span class="l-python-orange">}</span> <span class="l-python-green">milhas"</span>) 
valor_de_volta = milha.converterParaMetro(valor_na_milha) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_na_milha<span class="l-python-orange">}</span> <span class="l-python-green">milhas =</span> <span class="l-python-orange">{</span>valor_de_volta<span class="l-python-orange">}</span> <span class="l-python-green">metros"</span>)
                                  </code>
                              </pre>
                              <p>
                                  Nesse exemplo, a classe Medida serve como classe-base que contém os
                                  métodos-padrão para converter entre metros e a medida específica da
                                  classe
                                  derivada. As classes Polegada, Pe e Milha herdam da classe Medida e
                                  fornecem
                                  implementações personalizadas dos métodos de conversão. Isso permite que
                                  você converta valores entre os metros e as medidas específicas de cada
                                  classe.
                              </p>
                              <p>Saída do programa:</p>
                              <pre>
                              <code>
10.0 metros = 393.7007874015748 polegadas 
393.7007874015748 polegadas = 10.0 metros 
10.0 metros = 32.808398950131235 pés 
32.808398950131235 pés = 10.0 metros 
10.0 metros = 0.006213727366498068 milhas 
0.006213727366498068 milhas = 10.0 metros 

Process finished with exit code 0 
                              </code>
                             </pre>
                              <div class="modal-footer">
                                  <button type="button" class="btn btn-default"
                                      data-dismiss="modal">Fechar</button>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <div class="acessivel print">
            
            <h3>
                GABARITO DO DESAFIO
            </h3>
        
                <p> Aqui está uma implementação do desafio de conversão de medidas em
                    Python: </p>
                <pre>
                    <code>
<span class="l-python-orange">class</span> Medida: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, valor): 
<span class="l-python-violeta">self</span>.valor = valor 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange">return</span> valor_em_metros 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_na_medida): 
<span class="l-python-orange">return</span> valor_na_medida 

<span class="l-python-orange">class</span> Polegada(Medida): 
<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange">return</span> valor_em_metros / <span class="l-python-aqua">0.0254</span> 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_na_polegada): 
<span class="l-python-orange">return</span> valor_na_polegada * <span class="l-python-aqua">0.0254</span> 

<span class="l-python-orange">class</span> Pe(Medida): 
<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange"> return</span> valor_em_metros / <span class="l-python-aqua">0.3048</span> 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_no_pe): 
<span class="l-python-orange">return</span> valor_no_pe * <span class="l-python-aqua">0.3048</span> 

<span class="l-python-orange">class</span> Milha(Medida): 
<span class="l-python-orange">def</span> <span class="l-python-blue">converterDeMetro</span>(<span class="l-python-violeta">self</span>, valor_em_metros): 
<span class="l-python-orange">return</span> valor_em_metros / <span class="l-python-aqua">1609.34</span> 

<span class="l-python-orange">def</span> <span class="l-python-blue">converterParaMetro</span>(<span class="l-python-violeta">self</span>, valor_na_milha): 
<span class="l-python-orange">return</span> valor_na_milha * <span class="l-python-aqua">1609.34</span> 

# Exemplo de uso 
valor_em_metros = <span class="l-python-aqua">10.0</span> 

polegada = Polegada(valor_em_metros) 
valor_na_polegada = polegada.converterDeMetro(valor_em_metros) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_em_metros<span class="l-python-orange">}</span><span class="l-python-green"> metros = </span><span class="l-python-orange">{</span>valor_na_polegada<span class="l-python-orange">}</span> <span class="l-python-green">polegadas"</span>) 
valor_de_volta = polegada.converterParaMetro(valor_na_polegada) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_na_polegada<span class="l-python-orange">}</span> <span class="l-python-green">polegadas =</span> <span class="l-python-orange">{</span>valor_de_volta<span class="l-python-orange">}</span> <span class="l-python-green">metros"</span>) 

pe = Pe(valor_em_metros) 
valor_no_pe = pe.converterDeMetro(valor_em_metros) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_em_metros<span class="l-python-orange">}</span> <span class="l-python-green">metros =</span> <span class="l-python-orange">{</span>valor_no_pe<span class="l-python-orange">}</span> <span class="l-python-green">pés"</span>) 
valor_de_volta = pe.converterParaMetro(valor_no_pe) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_no_pe<span class="l-python-orange">}</span> <span class="l-python-green">pés =</span> <span class="l-python-orange">{</span>valor_de_volta<span class="l-python-orange">}</span> <span class="l-python-green">metros"</span>)

milha = Milha(valor_em_metros) 
valor_na_milha = milha.converterDeMetro(valor_em_metros) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_em_metros<span class="l-python-orange">}</span> <span class="l-python-green">metros =</span> <span class="l-python-orange">{</span>valor_na_milha<span class="l-python-orange">}</span> <span class="l-python-green">milhas"</span>) 
valor_de_volta = milha.converterParaMetro(valor_na_milha) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span>valor_na_milha<span class="l-python-orange">}</span> <span class="l-python-green">milhas =</span> <span class="l-python-orange">{</span>valor_de_volta<span class="l-python-orange">}</span> <span class="l-python-green">metros"</span>)
                      </code>
                  </pre>
                  <p>
                      Nesse exemplo, a classe Medida serve como classe-base que contém os
                      métodos-padrão para converter entre metros e a medida específica da
                      classe
                      derivada. As classes Polegada, Pe e Milha herdam da classe Medida e
                      fornecem
                      implementações personalizadas dos métodos de conversão. Isso permite que
                      você converta valores entre os metros e as medidas específicas de cada
                      classe.
                  </p>
                  <p>Saída do programa:</p>
                  <pre>
                    <code>
10.0 metros = 393.7007874015748 polegadas 
393.7007874015748 polegadas = 10.0 metros 
10.0 metros = 32.808398950131235 pés 
32.808398950131235 pés = 10.0 metros 
10.0 metros = 0.006213727366498068 milhas 
0.006213727366498068 milhas = 10.0 metros 

Process finished with exit code 0 
                              </code>
                            </pre>
                              
          </div>
       
      <p>
          Até aqui, você aprendeu um grande leque de estratégias utilizadas na programação orientada a
          objetos. Cada técnica tem suas vantagens e desvantagens e tenta abstrair algum conceito do mundo
          real, tornando-o flexível para a implementação de um código-fonte limpo e escalável, facilitando
          a
          sua manutenção a longo prazo.
      </p>
      <p>
          Conheça agora um conceito que tem ganhado cada vez mais espaço em projetos de <i>software</i>
          orientados a
          objetos: a “Associação”.
      </p>     
      </div>

      <div class="pagina">
        <div class="container">
            <h3>Associação</h3>
            <p>
                Associação é um conceito em programação orientada a objetos que modela o relacionamento entre
                duas
                ou mais classes. Assim como visto em herança, a associação envolve o uso de outras classes para
                construir classes mais complexas. Porém, a associação representa um relacionamento expresso pelo
                verbo <b>ter</b>, enquanto a herança é representada pelo verbo <b>ser</b>.
            </p>
            <div class="row">
                <div class="col-md-3 col-sm-4 col-xs-12">
                    <img src="objetos/layout_5_ilustra_pc_desmontado.png" class="img-responsive center-block">
                </div>
                <div class="col-md-9 col-sm-8 col-xs-12">
                    <p>Por exemplo, imagine um computador. Um computador <b>tem</b> uma placa-mãe, um
                        processador, um
                        disco rígido etc. Se um programa orientado a objetos fosse modelado para representar um
                        computador, a utilização de herança não seria a melhor representação desse cenário, pois
                        o computador <b>não é as suas peças</b>, ele <b>tem as peças</b>. É um complemento à sua
                        estrutura.
                        Nesse cenário, a utilização de “Associação” é a melhor escolha.
                    </p>
                </div>
            </div>
            <p>
                O conceito de associação é frequentemente usado no mundo real e devemos aproveitá-lo também no
                desenvolvimento de <i>software</i>. Um carro não é um motor, ele <b>tem</b> um. E uma máquina de
                café <b>tem</b> um
                moedor e uma unidade de infusão, mas não <b>é</b> nenhum deles. Por conta dessa grande
                similaridade com
                diversos casos do mundo real, o conceito de Associação tem ganhado muito espaço em projetos de
                <i>software</i> orientados a objeto. Existem três categorias de associação: associação,
                agregação e
                composição. Pode-se dizer que as três são associações, o que as diferem são apenas regras em
                seus
                conceitos, definindo restrições responsáveis por diferenciar o que é composição, agregação ou
                associação.
            </p>
            <div class="no-print">
              <p>Clique ou toque para visualizar o conteúdo.</p>
           
              <div class="painel-categorias">
                  <!-- <button type="button" class="btn-categorias btn-agregacao center-block" data-toggle="modal"
                      data-target="#modal-agregacao"></button> -->

                      <img src="objetos/esquema_3.png" class="btn-categorias btn-agregacao img-responsive center-block" data-toggle="modal" data-target="#modal-composicao" id="agregacao" srcset="">

                    <img src="objetos/esquema_2.png" class="btn-categorias btn-composicao center-block img-responsive" data-toggle="modal" data-target="#modal-composicao" id="composicao" srcset="">
              </div>

              <div class="legenda-imagem">
                Diagrama apresentando a sobreposição entre associação, agregação e composição <br>
                Fonte: Adaptado de Acervo Lima (c2022)
              </div>


              <div class="modal modal-100 fade" id="modal-composicao" aria-hidden="true">
                  <div class="modal-dialog">
                      <div class="modal-content no-print">
                          <div class="modal-header" style="padding-top: 30px;">
                              <button type="button" class="close" data-dismiss="modal"
                                  aria-hidden="true">&times;</button>
                              <h3 class="modal-title">
                                  <div class="container">Composição</div>
                              </h3>
                          </div>
                          <div class="modal-body">
                              <div class="container">
                                  <p>
                                      Em uma composição, as classes relacionadas só funcionam adequadamente
                                      juntas.
                                      Por conta disso, a composição é considerada uma <b>associação do tipo
                                          forte</b>, na
                                      qual há dependência entre as partes.
                                  </p>
                                  <p>
                                      Imagine uma casa e suas janelas. Componha a classe “Casa” com um objeto da
                                      classe “Janela” no quarto, um na cozinha, um no banheiro e um na sala. Caso
                                      seja
                                      criado um objeto da classe “Casa” e, logo após, seja destruído, também serão
                                      destruídas as suas janelas.
                                  </p>
                                  <p>
                                      Veja esse exemplo transformado em código. Primeiramente, será criada a
                                      classe
                                      “Janela”, que será necessária para a composição da classe “Casa”.
                                  </p>
                                  <p>
                                      A composição em Python envolve criar classes que contenham objetos de outras
                                      classes como atributos. Isso permite que um objeto contenha outros objetos,
                                      formando uma estrutura hierárquica. Observe este exemplo de composição
                                      usando as
                                      classes “Casa” e “Janela”:
                                  </p>
                                  <pre>
                                      <code>
  <span class="l-python-orange">class</span> Janela: 
  <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, localizacao): 
  <span class="l-python-violeta">self</span>.localizacao = localizacao 

  <span class="l-python-orange"> def</span> <span class="l-python-blue">abrir</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Janela na</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.localizacao<span class="l-python-orange">}</span> <span class="l-python-green">aberta."</span>) 

  <span class="l-python-orange">def</span> <span class="l-python-blue">fechar</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Janela na</span> <span class="l-python-orange">{</span<span class="l-python-violeta">>self</span>.localizacao<span class="l-python-orange">}</span> <span class="l-python-green">fechada."</span>) 

  <span class="l-python-orange">class</span> Casa: 
  <span class="l-python-orange">def</span><span class="l-python-roxo"> __init__</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-violeta">self</span>.quarto = Janela(<span class="l-python-green">"quarto"</span>) 
  <span class="l-python-violeta"> self</span>.cozinha = Janela(<span class="l-python-green">"cozinha"</span>) 
  <span class="l-python-violeta"> self</span>.banheiro = Janela(<span class="l-python-green">"banheiro"</span>) 
  <span class="l-python-violeta"> self</span>.sala = Janela(<span class="l-python-green">"sala"</span>) 

  <span class="l-python-orange">def</span> <span class="l-python-blue">abrir_janelas</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-violeta">self</span>.quarto.abrir() 
  <span class="l-python-violeta">self</span>.cozinha.abrir() 
  <span class="l-python-violeta">self</span>.banheiro.abrir() 
  <span class="l-python-violeta">self</span>.sala.abrir() 

  <span class="l-python-orange">def</span> <span class="l-python-blue">fechar_janelas</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-violeta">self</span>.quarto.fechar() 
  <span class="l-python-violeta">self</span>.cozinha.fechar() 
  <span class="l-python-violeta">self</span>.banheiro.fechar() 
  <span class="l-python-violeta">self</span>.sala.fechar() 

  # Criando uma casa 
  minha_casa = Casa() 

  # Abrindo todas as janelas 
  minha_casa.abrir_janelas() 

  # Fechando todas as janelas 
  minha_casa.fechar_janelas() 
                                      </code>
                                  </pre>
                                  <p>
                                      Nesse exemplo, a classe “Casa” contém quatro objetos da classe “Janela”, um
                                      para
                                      cada cômodo. A composição permite que você acesse e manipule as janelas da
                                      casa
                                      por meio de métodos na classe “Casa”. Quando a instância da classe “Casa” é
                                      destruída, as instâncias de “Janela” dentro dela também são destruídas. Isso
                                      demonstra o conceito de composição em Python.
                                  </p>
                                  <p>Saída do programa:</p>
                                  <pre>
                                      <code>
  Janela na quarto aberta. 
  Janela na cozinha aberta. 
  Janela na banheiro aberta. 
  Janela na sala aberta. 
  Janela na quarto fechada. 
  Janela na cozinha fechada. 
  Janela na banheiro fechada. 
  Janela na sala fechada. 

  Process finished with exit code 0 
                                      </code>
                                  </pre>
                                  <p>
                                      Conclui-se que, em uma composição, existe uma forte dependência entre as
                                      partes.
                                      Dessa forma, a composição é considerada uma associação do tipo forte, na
                                      qual há
                                      dependência entre as partes.
                                  </p>
                              </div>
                          </div>
                          <div class="modal-footer">
                              <button type="button" class="botao borda-primaria-03"
                                  data-dismiss="modal">Fechar</button>
                          </div>
                      </div>
                  </div>
              </div>
              <div class="modal modal-100 fade" id="modal-agregacao" aria-hidden="true">
                  <div class="modal-dialog">
                      <div class="modal-content no-print">
                          <div class="modal-header" style="padding-top: 30px;">
                              <button type="button" class="close" data-dismiss="modal"
                                  aria-hidden="true">&times;</button>
                              <h3 class="modal-title">
                                  <div class="container">Agregação</div>
                              </h3>
                          </div>
                          <div class="modal-body">
                              <div class="container">
                                  <p>
                                      Uma agregação é uma forma mais liberal de composição. Enquanto na composição
                                      só
                                      existe o todo, de forma que as classes só têm sentido juntas, na agregação,
                                      há
                                      um relacionamento típico de “proprietário” e “propriedade”, em que as duas
                                      classes existem por conta própria, porém juntas têm uma relação na qual uma
                                      classe é parte da outra, agregando informações ao proprietário.
                                  </p>
                                  <p>
                                      Por exemplo, um departamento pode ter um ou mais funcionários, mas um
                                      funcionário não <b>tem</b> um departamento, apenas <b>faz parte</b> de um departamento,
                                      novamente, um relacionamento do tipo proprietário e propriedade. Portanto,
                                      diz-se que a agregação tem uma natureza unidirecional.
                                  </p>
                                  <p>
                                      Do ponto de vista de objetos instanciados em um código, o tempo de vida do
                                      objeto da ‘classe propriedade” não depende do tempo de vida do objeto da
                                      “classe
                                      proprietário”. Ao remover qualquer um dos dois, o outro continuará existindo
                                      e
                                      funcionando por si só.
                                  </p>
                                  <p>
                                      Em programação orientada a objetos, a agregação é um conceito que descreve a
                                      relação entre um objeto “todo” e suas partes “partes”. Na agregação, um
                                      objeto
                                      principal (o “todo”) tem ou é composto por outros objetos (as “partes”), mas
                                      a
                                      vida das partes não depende do objeto principal. Isso significa que as
                                      partes
                                      podem existir independentemente do objeto principal.
                                  </p>
                                  <p>
                                      Agora será explorada a agregação em Python usando um exemplo de classes
                                      “Funcionário” e “Departamento”. O “Funcionário” será o objeto principal,
                                      enquanto o “Departamento” será uma parte agregada.
                                  </p>
                                  <p>Primeiramente, será criada a classe “Funcionario”:</p>
                                  <pre>
                                      <code>
  <span class="l-python-orange">class</span> Funcionario: 
  <span class="l-python-orange"> def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
  <span class="l-python-violeta">self</span>.nome = nome 

  <span class="l-python-orange">def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 
                                      </code>
                                  </pre>
                                  <p>
                                      A classe “Funcionario” contém um atributo “nome” e um método “getNome” para
                                      acessar o nome do funcionário. Agora, será criada a classe “Departamento”,
                                      que
                                      agregará funcionários:
                                  </p>
                                  <pre>
                                      <code>
  <span class="l-python-orange">class</span> Departamento: 
  <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
  <span class="l-python-violeta">self</span>.nome = nome 
  <span class="l-python-violeta">self</span>.funcionarios = [] 

  <span class="l-python-orange"> def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 

  <span class="l-python-orange">def</span> <span class="l-python-blue">adicionarFuncionario</span>(<span class="l-python-violeta">self</span>, funcionario): 
  <span class="l-python-violeta">self</span>.funcionarios.append(funcionario) 
                                      </code>
                                  </pre>
                                  <p>
                                      A classe “Departamento” contém um atributo “nome”, que representa o nome do
                                      departamento e uma lista de funcionários. Também tem métodos “getNome” para
                                      acessar o nome do departamento e “adicionarFuncionario” para adicionar
                                      funcionários à lista.
                                  </p>
                                  <p>Veja uma demonstração da agregação usando essas classes:</p>
                                  <pre>
                                      <code>
  <span class="l-python-orange">class</span> Funcionario: 
  <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
  <span class="l-python-violeta">self</span>.nome = nome 

  <span class="l-python-orange">def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 

  <span class="l-python-orange">class</span> Departamento: 
  <span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
  <span class="l-python-violeta">self</span>.nome = nome 
  <span class="l-python-violeta">self</span>.funcionarios = [] 

  <span class="l-python-orange">def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
  <span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 

  <span class="l-python-orange">def</span> <span class="l-python-blue">adicionarFuncionario</span>(<span class="l-python-violeta">self</span>, funcionario): 
  <span class="l-python-violeta">self</span>.funcionarios.append(funcionario) 
  # Criando funcionários 
  funcionario1 = Funcionario(<span class="l-python-green">"Alice"</span>) 
  funcionario2 = Funcionario(<span class="l-python-green">"Bob"</span>) 
  funcionario3 = Funcionario(<span class="l-python-green">"Charlie"</span>) 

  # Criando um departamento 
  departamento = Departamento(<span class="l-python-green">"Recursos Humanos"</span>) 

  # Adicionando funcionários ao departamento 
  departamento.adicionarFuncionario(funcionario1) 
  departamento.adicionarFuncionario(funcionario2) 
  departamento.adicionarFuncionario(funcionario3) 

  # Obtendo informações sobre o departamento e seus funcionários 
  <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Departamento:</span> <span class="l-python-orange">{</span>departamento.getNome()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
  <span class="l-python-aescuro">print</span>(<span class="l-python-green">"Funcionários no departamento:"</span>) 
  <span class="l-python-orange">for</span> funcionario <span class="l-python-orange">in</span> departamento.funcionarios: 
  <span class="l-python-aescuro">print</span>(funcionario.getNome()) 
                                      </code>
                                  </pre>
                                  <p>Saída do programa: </p>
                                  <pre>
                                      <code>
  Departamento: Recursos Humanos 
  Funcionários no departamento: 
  Alice 
  Bob 
  Charlie 

  Process finished with exit code 0 
                                      </code>
                                  </pre>
                                  <p>
                                      Nesse exemplo, foram criados funcionários (objetos da classe “Funcionario”)
                                      e um
                                      departamento (objeto da classe “Departamento”). Em seguida, foram
                                      adicionados os
                                      funcionários ao departamento usando o método “adicionarFuncionario”. O
                                      departamento contém uma lista de funcionários agregados a ele.
                                  </p>
                                  <p>
                                      A agregação permite que o departamento mantenha uma coleção de funcionários,
                                      mas
                                      os funcionários podem existir independentemente do departamento. Isso
                                      demonstra
                                      como a agregação é uma forma útil de modelar relacionamentos entre objetos
                                      em
                                      Python.
                                  </p>
                                  <div class="caixa-destaque icone anotar">
                                      <p>
                                          Perceba que, no exemplo de composição, os objetos “Janela” eram
                                          instanciados
                                          dentro da classe “Casa”. Esse comportamento fazia com que os objetos
                                          nascessem e morressem dentro de um objeto da classe “Casa”, criando uma
                                          dependência forte. Já no exemplo de agregação, foi instanciada a classe
                                          “Funcionario” fora da classe “Departamento”, enviando apenas uma
                                          referência
                                          para dentro. Essa diferença torna possível a existência dos dois de
                                          maneira
                                          independente.
                                      </p>
                                  </div>
                              </div>
                          </div>
                          <div class="modal-footer">
                              <button type="button" class="botao borda-primaria-03"
                                  data-dismiss="modal">Fechar</button>
                          </div>
                      </div>
                  </div>
              </div>
            </div>

            <div class="acessivel print">
              <h3>
                  Composição
              </h3>
                        
              <p>
                  Em uma composição, as classes relacionadas só funcionam adequadamente
                  juntas.
                  Por conta disso, a composição é considerada uma <b>associação do tipo
                      forte</b>, na
                  qual há dependência entre as partes.
              </p>
              <p>
                  Imagine uma casa e suas janelas. Componha a classe “Casa” com um objeto da
                  classe “Janela” no quarto, um na cozinha, um no banheiro e um na sala. Caso
                  seja
                  criado um objeto da classe “Casa” e, logo após, seja destruído, também serão
                  destruídas as suas janelas.
              </p>
              <p>
                  Veja esse exemplo transformado em código. Primeiramente, será criada a
                  classe
                  “Janela”, que será necessária para a composição da classe “Casa”.
              </p>
              <p>
                  A composição em Python envolve criar classes que contenham objetos de outras
                  classes como atributos. Isso permite que um objeto contenha outros objetos,
                  formando uma estrutura hierárquica. Observe este exemplo de composição
                  usando as
                  classes “Casa” e “Janela”:
              </p>
              <pre>
                  <code>
<span class="l-python-orange">class</span> Janela: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, localizacao): 
<span class="l-python-violeta">self</span>.localizacao = localizacao 

<span class="l-python-orange"> def</span> <span class="l-python-blue">abrir</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Janela na</span> <span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.localizacao<span class="l-python-orange">}</span> <span class="l-python-green">aberta."</span>) 

<span class="l-python-orange">def</span> <span class="l-python-blue">fechar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Janela na</span> <span class="l-python-orange">{</span<span class="l-python-violeta">>self</span>.localizacao<span class="l-python-orange">}</span> <span class="l-python-green">fechada."</span>) 

<span class="l-python-orange">class</span> Casa: 
<span class="l-python-orange">def</span><span class="l-python-roxo"> __init__</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-violeta">self</span>.quarto = Janela(<span class="l-python-green">"quarto"</span>) 
<span class="l-python-violeta"> self</span>.cozinha = Janela(<span class="l-python-green">"cozinha"</span>) 
<span class="l-python-violeta"> self</span>.banheiro = Janela(<span class="l-python-green">"banheiro"</span>) 
<span class="l-python-violeta"> self</span>.sala = Janela(<span class="l-python-green">"sala"</span>) 

<span class="l-python-orange">def</span> <span class="l-python-blue">abrir_janelas</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-violeta">self</span>.quarto.abrir() 
<span class="l-python-violeta">self</span>.cozinha.abrir() 
<span class="l-python-violeta">self</span>.banheiro.abrir() 
<span class="l-python-violeta">self</span>.sala.abrir() 

<span class="l-python-orange">def</span> <span class="l-python-blue">fechar_janelas</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-violeta">self</span>.quarto.fechar() 
<span class="l-python-violeta">self</span>.cozinha.fechar() 
<span class="l-python-violeta">self</span>.banheiro.fechar() 
<span class="l-python-violeta">self</span>.sala.fechar() 

# Criando uma casa 
minha_casa = Casa() 

# Abrindo todas as janelas 
minha_casa.abrir_janelas() 

# Fechando todas as janelas 
minha_casa.fechar_janelas() 
                  </code>
              </pre>
              <p>
                  Nesse exemplo, a classe “Casa” contém quatro objetos da classe “Janela”, um
                  para
                  cada cômodo. A composição permite que você acesse e manipule as janelas da
                  casa
                  por meio de métodos na classe “Casa”. Quando a instância da classe “Casa” é
                  destruída, as instâncias de “Janela” dentro dela também são destruídas. Isso
                  demonstra o conceito de composição em Python.
              </p>
              <p>Saída do programa:</p>
              <pre>
                  <code>
Janela na quarto aberta. 
Janela na cozinha aberta. 
Janela na banheiro aberta. 
Janela na sala aberta. 
Janela na quarto fechada. 
Janela na cozinha fechada. 
Janela na banheiro fechada. 
Janela na sala fechada. 

Process finished with exit code 0 
                  </code>
              </pre>
              <p>
                  Conclui-se que, em uma composição, existe uma forte dependência entre as
                  partes.
                  Dessa forma, a composição é considerada uma associação do tipo forte, na
                  qual há
                  dependência entre as partes.
              </p>
                            
              <h3>
                Agregação
              </h3>
                        
              <p>
                  Uma agregação é uma forma mais liberal de composição. Enquanto na composição
                  só
                  existe o todo, de forma que as classes só têm sentido juntas, na agregação,
                  há
                  um relacionamento típico de “proprietário” e “propriedade”, em que as duas
                  classes existem por conta própria, porém juntas têm uma relação na qual uma
                  classe é parte da outra, agregando informações ao proprietário.
              </p>
              <p>
                  Por exemplo, um departamento pode ter um ou mais funcionários, mas um
                  funcionário não tem um departamento, apenas faz parte de um departamento,
                  novamente, um relacionamento do tipo proprietário e propriedade. Portanto,
                  diz-se que a agregação tem uma natureza unidirecional.
              </p>
              <p>
                  Do ponto de vista de objetos instanciados em um código, o tempo de vida do
                  objeto da ‘classe propriedade” não depende do tempo de vida do objeto da
                  “classe
                  proprietário”. Ao remover qualquer um dos dois, o outro continuará existindo
                  e
                  funcionando por si só.
              </p>
              <p>
                  Em programação orientada a objetos, a agregação é um conceito que descreve a
                  relação entre um objeto “todo” e suas partes “partes”. Na agregação, um
                  objeto
                  principal (o “todo”) tem ou é composto por outros objetos (as “partes”), mas
                  a
                  vida das partes não depende do objeto principal. Isso significa que as
                  partes
                  podem existir independentemente do objeto principal.
              </p>
              <p>
                  Agora será explorada a agregação em Python usando um exemplo de classes
                  “Funcionário” e “Departamento”. O “Funcionário” será o objeto principal,
                  enquanto o “Departamento” será uma parte agregada.
              </p>
              <p>Primeiramente, será criada a classe “Funcionario”:</p>
              <pre>
                  <code>
<span class="l-python-orange">class</span> Funcionario: 
<span class="l-python-orange"> def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
<span class="l-python-violeta">self</span>.nome = nome 

<span class="l-python-orange">def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 
                  </code>
              </pre>
              <p>
                  A classe “Funcionario” contém um atributo “nome” e um método “getNome” para
                  acessar o nome do funcionário. Agora, será criada a classe “Departamento”,
                  que
                  agregará funcionários:
              </p>
              <pre>
                  <code>
<span class="l-python-orange">class</span> Departamento: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
<span class="l-python-violeta">self</span>.nome = nome 
<span class="l-python-violeta">self</span>.funcionarios = [] 

<span class="l-python-orange"> def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 

<span class="l-python-orange">def</span> <span class="l-python-blue">adicionarFuncionario</span>(<span class="l-python-violeta">self</span>, funcionario): 
<span class="l-python-violeta">self</span>.funcionarios.append(funcionario) 
                  </code>
              </pre>
              <p>
                  A classe “Departamento” contém um atributo “nome”, que representa o nome do
                  departamento e uma lista de funcionários. Também tem métodos “getNome” para
                  acessar o nome do departamento e “adicionarFuncionario” para adicionar
                  funcionários à lista.
              </p>
              <p>Veja uma demonstração da agregação usando essas classes:</p>
              <pre>
                  <code>
<span class="l-python-orange">class</span> Funcionario: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
<span class="l-python-violeta">self</span>.nome = nome 

<span class="l-python-orange">def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 

<span class="l-python-orange">class</span> Departamento: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
<span class="l-python-violeta">self</span>.nome = nome 
<span class="l-python-violeta">self</span>.funcionarios = [] 

<span class="l-python-orange">def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 

<span class="l-python-orange">def</span> <span class="l-python-blue">adicionarFuncionario</span>(<span class="l-python-violeta">self</span>, funcionario): 
<span class="l-python-violeta">self</span>.funcionarios.append(funcionario) 
# Criando funcionários 
funcionario1 = Funcionario(<span class="l-python-green">"Alice"</span>) 
funcionario2 = Funcionario(<span class="l-python-green">"Bob"</span>) 
funcionario3 = Funcionario(<span class="l-python-green">"Charlie"</span>) 

# Criando um departamento 
departamento = Departamento(<span class="l-python-green">"Recursos Humanos"</span>) 

# Adicionando funcionários ao departamento 
departamento.adicionarFuncionario(funcionario1) 
departamento.adicionarFuncionario(funcionario2) 
departamento.adicionarFuncionario(funcionario3) 

# Obtendo informações sobre o departamento e seus funcionários 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"Departamento:</span> <span class="l-python-orange">{</span>departamento.getNome()<span class="l-python-orange">}</span><span class="l-python-green">"</span>) 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">"Funcionários no departamento:"</span>) 
<span class="l-python-orange">for</span> funcionario <span class="l-python-orange">in</span> departamento.funcionarios: 
<span class="l-python-aescuro">print</span>(funcionario.getNome()) 
                  </code>
              </pre>
              <p>Saída do programa: </p>
              <pre>
                  <code>
Departamento: Recursos Humanos 
Funcionários no departamento: 
Alice 
Bob 
Charlie 

Process finished with exit code 0 
                  </code>
              </pre>
              <p>
                  Nesse exemplo, foram criados funcionários (objetos da classe “Funcionario”)
                  e um
                  departamento (objeto da classe “Departamento”). Em seguida, foram
                  adicionados os
                  funcionários ao departamento usando o método “adicionarFuncionario”. O
                  departamento contém uma lista de funcionários agregados a ele.
              </p>
              <p>
                  A agregação permite que o departamento mantenha uma coleção de funcionários,
                  mas
                  os funcionários podem existir independentemente do departamento. Isso
                  demonstra
                  como a agregação é uma forma útil de modelar relacionamentos entre objetos
                  em
                  Python.
              </p>
              <div class="caixa-destaque icone anotar">
                  <p>
                      Perceba que, no exemplo de composição, os objetos “Janela” eram
                      instanciados
                      dentro da classe “Casa”. Esse comportamento fazia com que os objetos
                      nascessem e morressem dentro de um objeto da classe “Casa”, criando uma
                      dependência forte. Já no exemplo de agregação, foi instanciada a classe
                      “Funcionario” fora da classe “Departamento”, enviando apenas uma
                      referência
                      para dentro. Essa diferença torna possível a existência dos dois de
                      maneira
                      independente.
                  </p>
              </div>                    
            </div>

            <p>
                Agora você já conhece a composição e a agregação e compreende que ambas são tipos mais
                restritivos
                de associação. Ou seja, os exemplos vistos anteriormente podem ser chamados de associação.
                Criando
                um conceito geral, é possível dizer que a associação é a simples relação entre duas classes, por
                meio de seus objetos. Uma associação pode ser um para um, um para muitos, muitos para um ou
                muitos
                para muitos.
            </p>
            <div class="caixa-destaque">
                <p>
                    Entretanto, existe um tipo de associação que não se enquadra nem como composição nem como
                    agregação. Trata-se da <b>associação bidirecional</b>.
                </p>
            </div>
            <p>
                Como a agregação e a composição só podem ser unidirecionais, um relacionamento bidirecional é
                exclusivamente uma associação. Para entender melhor, é necessário começar pelas semelhanças.
            </p>
            <p>
                Uma associação, assim como a agregação, é um relacionamento semanticamente fraco entre duas
                classes
                distintas. Ou seja, as duas classes existem sem depender uma da outra. Também como a composição
                e a
                agregação, uma associação é um relacionamento de “uso” (identificado pelo verbo TER) entre dois
                ou
                mais objetos.
            </p>
            <p>
                Apesar das semelhanças, uma associação bidirecional não tem uma estrutura de proprietário e
                propriedade, sendo dois objetos completamente independentes. Os objetos que fazem parte do
                relacionamento de associação podem ser criados e destruídos de forma independente e contêm
                informações e comportamentos de maneira independente também.
            </p>
            <p>
                A associação em Python é um relacionamento entre objetos em que um objeto pode estar relacionado
                a
                outro, mas eles não são partes essenciais um do outro. Diferentemente da agregação e da
                composição,
                na associação, os objetos podem existir independentemente um do outro sem compartilhar uma
                relação
                forte. A associação é frequentemente usada quando você deseja estabelecer uma conexão ou
                referência
                entre dois objetos sem criar uma dependência rígida entre eles.
            </p>
            <p>
                Observe um exemplo de associação entre duas classes: Professor e Disciplina. Cada professor pode
                estar associado a várias disciplinas, mas as disciplinas e os professores são objetos
                independentes.
            </p>
            <pre>
                <code>
<span class="l-python-orange">class</span> Professor: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
<span class="l-python-violeta">self</span>.nome = nome 

<span class="l-python-orange">def</span> <span class="l-python-blue">ensinar</span>(<span class="l-python-violeta">self</span>, disciplina): 
<span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome<span class="l-python-orange">}</span> <span class="l-python-green">está ensinando a disciplina</span> <span class="l-python-orange">{</span>disciplina.getNome()<span class="l-python-orange">}</span><span class="l-python-green">"</span>)


<span class="l-python-orange">class</span> Disciplina: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
<span class="l-python-violeta">self</span>.nome = nome 

<span class="l-python-orange">def</span> <span class="l-python-blue">getNome</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">return</span> <span class="l-python-violeta">self</span>.nome 


# Criando objetos de Professor e Disciplina 
professor1 = Professor(<span class="l-python-green">"Dr. Smith"</span>) 
professor2 = Professor(<span class="l-python-green">"Prof. Johnson"</span>) 
disciplina1 = Disciplina(<span class="l-python-green">"Matemática"</span>) 
disciplina2 = Disciplina(<span class="l-python-green">"Física"</span>) 

# Estabelecendo associações 
professor1.ensinar(disciplina1) 
professor2.ensinar(disciplina2) 
professor1.ensinar(disciplina2)
                </code>
            </pre>
            <p>
                No exemplo, há as classes “Professor” e “Disciplina”. Cada professor pode ensinar várias
                disciplinas. A associação ocorre quando é chamado o método “ensinar” do objeto “Professor” e
                passado
                um objeto “Disciplina” como parâmetro.
            </p>
            <p>
                A associação permite que objetos interajam de maneira mais flexível, sem criar uma dependência
                rígida. Cada objeto mantém sua independência, e a associação ocorre quando necessário.
            </p>
            <p>
                Em resumo, a associação em Python permite que objetos se relacionem de forma flexível e é útil
                quando você precisa estabelecer conexões entre objetos sem criar uma dependência forte.
            </p>
            <p>Saída do programa:</p>
            <pre>
                <code>
Dr. Smith está ensinando a disciplina Matemática 
Prof. Johnson está ensinando a disciplina Física 
Dr. Smith está ensinando a disciplina Física 

Process finished with exit code 0 
                </code>
            </pre>
            <p>
                Por exemplo, imagine um namoro. Há apenas uma classe chamada “Pessoa”. A classe “Pessoa” tem
                suas
                características e comportamentos, funcionando e existindo de maneira independente. Entretanto,
                há
                uma propriedade cônjuge que faz referência a um outro objeto da classe “Pessoa”. Esse tipo de
                relacionamento é chamado de bidirecional, pois os dois objetos relacionam-se um com o outro, de
                maneira bidirecional. Veja o código a seguir:
            </p>
            <pre>
                <code>
<span class="l-python-orange">class</span> Pessoa: 
<span class="l-python-orange">def</span> <span class="l-python-roxo">__init__</span>(<span class="l-python-violeta">self</span>, nome): 
<span class="l-python-violeta">self</span>.nome = nome 
<span class="l-python-violeta">self</span>.conjuge = None  # Inicialmente, não há cônjuge 

<span class="l-python-orange">def</span> <span class="l-python-blue">casar_com</span>(<span class="l-python-violeta">self</span>, outra_pessoa): 
<span class="l-python-orange">if not</span> <span class="l-python-violeta">self</span>.conjuge <span class="l-python-orange">and not</span> outra_pessoa.conjuge: 
    <span class="l-python-violeta">self</span>.conjuge = outra_pessoa 
    outra_pessoa.conjuge = <span class="l-python-violeta">self</span> 
    <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome<span class="l-python-orange">}</span> <span class="l-python-green">e</span> <span class="l-python-orange">{</span>outra_pessoa.nome<span class="l-python-orange">}</span><span class="l-python-green"> agora estão casados."</span>) 
<span class="l-python-green"> else</span>: 
    <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome<span class="l-python-orange">}</span> <span class="l-python-green">ou</span> <span class="l-python-orange">{</span>outra_pessoa.nome<span class="l-python-green">}</span> <span class="l-python-green">já estão casados."</span>) 

<span class="l-python-orange">def</span> <span class="l-python-blue">divorciar</span>(<span class="l-python-violeta">self</span>): 
<span class="l-python-orange">if</span> <span class="l-python-violeta">self</span>.conjuge: 
    outro = <span class="l-python-violeta">self</span>.conjuge 
    <span class="l-python-violeta">self</span>.conjuge = <span class="l-python-orange">None</span> 
    outro.conjuge = <span class="l-python-orange">None</span> 
    <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome<span class="l-python-orange">}</span> <span class="l-python-green">e</span> <span class="l-python-orange">{</span>outro.nome<span class="l-python-orange">}</span> <span class="l-python-green">agora estão divorciados."</span>) 
<span class="l-python-orange">else</span>: 
    <span class="l-python-aescuro">print</span>(<span class="l-python-green">f"</span><span class="l-python-orange">{</span><span class="l-python-violeta">self</span>.nome<span class="l-python-orange">}</span> <span class="l-python-green">não está casado."</span>) 

# Criando duas pessoas 
pessoa1 = Pessoa(<span class="l-python-green">"Alice"</span>) 
pessoa2 = Pessoa(<span class="l-python-green">"Bob"</span>) 

# Casando as duas pessoas 
pessoa1.casar_com(pessoa2) 

# Tentando casar novamente 
pessoa3 = Pessoa(<span class="l-python-green">"Charlie"</span>) 
pessoa1.casar_com(pessoa3) 

# Divorciando 
pessoa1.divorciar() 
                </code>
            </pre>
            <p>
                Há a classe “Pessoa” com a propriedade “cônjuge”. O método <b>casar_com</b> permite casar duas pessoas
                e
                criar um relacionamento bidirecional, enquanto o método <b>divorciar</b> permite o divórcio, removendo
                o
                relacionamento. Esse é um exemplo de relacionamento bidirecional, em que os objetos da mesma
                classe
                se relacionam entre si de forma independente.
            </p>
            <p>Saída do programa: </p>
            <pre>
                <code>
Alice e Bob agora estão casados. 
Alice ou Charlie já estão casados. 
Alice e Bob agora estão divorciados. 

Process finished with exit code 0  
                </code>
            </pre>
            
        </div>
      </div>

      <div class="pagina">
        <div class="container">
            <h3>Sintaxe da linguagem para orientação a objeto </h3>
            <p>
                A programação orientada a objetos (POO) é uma metodologia de desenvolvimento de <i>software</i>
                amplamente
                usada em Python. Ela permite organizar e estruturar o código em torno de objetos, que são
                instâncias
                de classes, para representar conceitos do mundo real de forma mais clara e eficiente.
            </p>
            <div class="no-print" aria-hidden="true">
                <p>Clique ou toque para visualizar o conteúdo. </p>
                <div class="painel-objeto centralizar show-desk">
                    <button class="btn-definicao-classes center-block" data-toggle="modal"
                        data-target="#modal-classes"><img src="./objetos/painel_bt1.png" alt=""></button>

                    <button class="btn-atributos center-block" data-toggle="modal"
                        data-target="#modal-atributos"><img src="./objetos/painel_bt2.png" alt=""></button>

                    <button class="btn-encapsulamento center-block" data-toggle="modal"
                        data-target="#modal-encapsulamento"><img src="./objetos/painel_bt3.png" alt=""></button>

                    <button class="btn-metodos center-block" data-toggle="modal"
                        data-target="#modal-metodos"><img src="./objetos/painel_bt4.png" alt=""></button>

                    <button class="btn-heranca center-block" data-toggle="modal"
                        data-target="#modal-heranca"><img src="./objetos/painel_bt5.png" alt=""></button>

                    <button class="btn-interface center-block" data-toggle="modal"
                        data-target="#modal-interface"><img src="./objetos/painel_bt6.png" alt=""></button>

                    <button class="btn-polimorfismo-1 center-block" data-toggle="modal"
                        data-target="#modal-polimorfismo-1"><img src="./objetos/painel_bt7.png" alt=""></button>

                    <button class="btn-modificadores center-block" data-toggle="modal"
                        data-target="#modal-modificadores"><img src="./objetos/painel_bt8.png" alt=""></button>

                    <button class="btn-associacao center-block" data-toggle="modal"
                        data-target="#modal-associacao"><img src="./objetos/painel_bt9.png" alt=""></button>

                </div>

                <div class="painel-objeto-mobi show-mobi">
                    <button class="btn-definicao-classes1 btn-classes center-block" data-toggle="modal"
                        data-target="#modal-classes"><img src="./objetos/painel_bt1.png" alt=""></button>

                    <button class="btn-atributos1 center-block" data-toggle="modal"
                        data-target="#modal-atributos"><img src="./objetos/painel_bt2.png" alt=""></button>

                    <button class="btn-encapsulamento1 center-block" data-toggle="modal"
                        data-target="#modal-encapsulamento"><img src="./objetos/painel_bt3.png" alt=""></button>

                    <button class="btn-metodos1 center-block" data-toggle="modal"
                        data-target="#modal-metodos"><img src="./objetos/painel_bt4.png" alt=""></button>

                    <button class="btn-heranca1 center-block" data-toggle="modal"
                        data-target="#modal-heranca"><img src="./objetos/painel_bt5.png" alt=""></button>

                    <button class="btn-interface1 center-block" data-toggle="modal"
                        data-target="#modal-interface"><img src="./objetos/painel_bt6.png" alt=""></button>

                    <button class="btn-polimorfismo-11 center-block" data-toggle="modal"
                        data-target="#modal-polimorfismo-1"><img src="./objetos/painel_bt7.png" alt=""></button>

                    <button class="btn-modificadores1 center-block" data-toggle="modal"
                        data-target="#modal-modificadores"><img src="./objetos/painel_bt8.png" alt=""></button>

                    <button class="btn-associacao1 center-block" data-toggle="modal"
                        data-target="#modal-associacao"><img src="./objetos/painel_bt9.png" alt=""></button>

                </div>


                <div class="modal fade" id="modal-classes" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Definição de classes e objetos </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    Em Python, as classes são a espinha dorsal da programação orientada a
                                    objetos.
                                    Uma
                                    classe é um plano ou um modelo para criar objetos que compartilham atributos
                                    e
                                    comportamentos comuns. Para criar um objeto, você instancia uma classe. Os
                                    objetos
                                    são instâncias de uma classe e contêm atributos (variáveis de instância) e
                                    métodos
                                    (funções associadas).
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-atributos" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Atributos </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    Os atributos são características que descrevem o estado de um objeto. Em
                                    Python,
                                    eles podem ser definidos dentro do método construtor __init__ da classe. Os
                                    atributos podem ser públicos, protegidos ou privados, indicados por
                                    convenções
                                    de nome, mas o acesso real é determinado pelos modificadores de acesso.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-encapsulamento" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Encapsulamento </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    O encapsulamento é a prática de ocultar os detalhes internos de uma classe e
                                    fornecer uma interface pública para interagir com o objeto. Em Python, os
                                    atributos e os métodos podem ser acessados publicamente, protegidos ou
                                    privadamente, embora a linguagem confie na convenção de nome para a
                                    proteção.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-metodos" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Métodos </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    Os métodos são funções definidas em uma classe que representam os
                                    comportamentos
                                    dos objetos. Métodos são chamados em instâncias da classe para realizar
                                    ações ou
                                    retornar informações específicas.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-heranca" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Herança </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    A herança permite que uma classe herde atributos e métodos de outra classe.
                                    Em
                                    Python, uma classe filha pode herdar de uma classe pai usando a notação
                                    “class
                                    Filha(Pai):”. Isso permite reutilizar código e estabelecer uma hierarquia de
                                    classes.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-interface" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Interface </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    Em Python, não existem interfaces no sentido estrito de linguagens como
                                    Python.
                                    No entanto, você pode usar classes abstratas para definir uma estrutura
                                    comum
                                    que outras classes devem implementar. As classes abstratas podem ser criadas
                                    usando o módulo abc.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-polimorfismo-1" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Polimorfismo </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    O polimorfismo permite que objetos de diferentes classes sejam tratados de
                                    forma
                                    semelhante. Em Python, o polimorfismo é alcançado quando objetos de classes
                                    diferentes respondem a métodos com o mesmo nome, independentemente de suas
                                    implementações específicas.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-modificadores" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Modificadores de acesso </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    Python não tem modificadores de acesso, como public, private e protected,
                                    como
                                    em algumas outras linguagens. Em vez disso, a linguagem confia em convenções
                                    de
                                    nome, como _atributo para indicar atributos protegidos e __atributo para
                                    indicar
                                    atributos privados.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal fade" id="modal-associacao" tabindex="-1" role="dialog"
                    aria-labelledby="myModalLabel">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal"
                                    aria-label="Close"><span aria-hidden="true">×</span></button>
                                <h4 class="modal-title" id="myModalLabel">Associação, agregação e composição
                                </h4>
                            </div>
                            <div class="modal-body">
                                <p>
                                    Python permite definir relacionamentos entre classes. A associação é um
                                    relacionamento simples entre classes, em que uma classe usa outra. A
                                    agregação é
                                    uma forma de associação mais forte, indicando que uma classe “tem” outra,
                                    mas
                                    ambas podem existir independentemente. A composição é uma forma mais forte
                                    de
                                    agregação, indicando que uma classe é composta por outras, e elas não
                                    existem
                                    independentemente.
                                </p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default"
                                    data-dismiss="modal">Fechar</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="acessivel print">
                <h3>Definição de classes e objetos</h3>
                <p>
                    Em Python, as classes são a espinha dorsal da programação orientada a objetos. Uma classe é
                    um
                    plano ou um modelo para criar objetos que compartilham atributos e comportamentos comuns.
                    Para
                    criar um objeto, você instancia uma classe. Os objetos são instâncias de uma classe e contêm
                    atributos (variáveis de instância) e métodos (funções associadas).
                </p>
                <h3>Atributos</h3>
                <p>
                    Os atributos são características que descrevem o estado de um objeto. Em Python, eles podem
                    ser
                    definidos dentro do método construtor __init__ da classe. Os atributos podem ser públicos,
                    protegidos ou privados, indicados por convenções de nome, mas o acesso real é determinado
                    pelos
                    modificadores de acesso.
                </p>
                <h3>Encapsulamento</h3>
                <p>
                    O encapsulamento é a prática de ocultar os detalhes internos de uma classe e fornecer uma
                    interface pública para interagir com o objeto. Em Python, os atributos e os métodos podem
                    ser
                    acessados publicamente, protegidos ou privadamente, embora a linguagem confie na convenção
                    de
                    nome para a proteção.
                </p>
                <h3> Métodos</h3>
                <p>
                    Os métodos são funções definidas em uma classe que representam os comportamentos dos
                    objetos.
                    Métodos são chamados em instâncias da classe para realizar ações ou retornar informações
                    específicas.
                </p>
                <h3>Herança</h3>
                <p>
                    A herança permite que uma classe herde atributos e métodos de outra classe. Em Python, uma
                    classe filha pode herdar de uma classe pai usando a notação “class Filha(Pai):”. Isso
                    permite
                    reutilizar código e estabelecer uma hierarquia de classes.
                </p>
                <h3>Interface</h3>
                <p>
                    Em Python, não existem interfaces no sentido estrito de linguagens como Python. No entanto,
                    você
                    pode usar classes abstratas para definir uma estrutura comum que outras classes devem
                    implementar. As classes abstratas podem ser criadas usando o módulo abc.
                </p>
                <h3>Polimorfismo</h3>
                <p>
                    O polimorfismo permite que objetos de diferentes classes sejam tratados de forma semelhante.
                    Em
                    Python, o polimorfismo é alcançado quando objetos de classes diferentes respondem a métodos
                    com
                    o mesmo nome, independentemente de suas implementações específicas.
                </p>
                <h3> Modificadores de acesso</h3>
                <p>
                    Python não tem modificadores de acesso, como public, private e protected, como em algumas
                    outras
                    linguagens. Em vez disso, a linguagem confia em convenções de nome, como _atributo para
                    indicar
                    atributos protegidos e __atributo para indicar atributos privados.
                </p>
                <h3>Associação, agregação e composição</h3>
                <p>
                    Python permite definir relacionamentos entre classes. A associação é um relacionamento
                    simples
                    entre classes, em que uma classe usa outra. A agregação é uma forma de associação mais
                    forte,
                    indicando que uma classe “tem” outra, mas ambas podem existir independentemente. A
                    composição é
                    uma forma mais forte de agregação, indicando que uma classe é composta por outras, e elas
                    não
                    existem independentemente.
                </p>
            </div>

            <p class="marginTop">
                A programação orientada a objetos em Python oferece uma ampla flexibilidade e uma sintaxe clara
                para
                criar estruturas de classe e objetos que representam entidades e conceitos do mundo real. É uma
                abordagem valiosa para desenvolver um <i>software</i> robusto e bem estruturado.
            </p>
        </div>
      </div>


    </section>
    <!-- - - - - - - - - - - - - - - - não alterar abaixo- - - - - - - - - - - - -->

    <!--
        <footer class="text-center no-print">
          <ul class="pagination">

          </ul>
        </footer>
        -->


    <!-- Modais -->
    <div class="modal fade" id="modal-polimorfismo01" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                aria-hidden="true">×</span></button>
            <h4 class="modal-title" id="myModalLabel">Polimorfismo estático</h4>
          </div>
          <div class="modal-body">
            <p>Seguindo o conceito de polimorfismo, o <b>polimorfismo estático</b> é uma forma de adicionar diferentes
              comportamentos para o mesmo método. O fato de ser estático significa que o compilador consegue determinar
              qual comportamento/versão será executado.</p>
            <div class="caixa-destaque icone anotar">
              <p>Em seguida, você aprenderá que existe outro tipo de polimorfismo, no qual só é possível validar qual
                comportamento/versão será executado em tempo de execução (isto é, executando o código-fonte).</p>
            </div>
            <p>O polimorfismo estático também é conhecido como polimorfismo em tempo de compilação (em inglês,
              <i>compile-time polymorphism</i>), ligação estática (<i>static binding</i>), ligação em tempo de
              compilação (<i>compile-time binding</i>), ligação precoce (<i>early binding</i>) e <b>sobrecarga de
                método</b> (<i>method overloading</i>) – sendo esta última a forma mais comum. </p>
            <p>Existem diversas formas diferentes de realizar um polimorfismo estático, dependendo do <i>kit</i> de
              recursos da linguagem de programação utilizada. A única regra é que a implementação deve atender ao
              conceito. Ou seja, deve ser possível determinar qual comportamento será executado (do método ou classe
              polimorfo) ainda no compilador (sem a necessidade de executar o código).</p>
            <p>Uma das formas mais conhecidas de polimorfismo em Java é a <b>sobrecarga de método</b>. Nela, você pode
              implementar diversos métodos com o mesmo nome dentro da mesma classe, mudando apenas o conjunto de
              argumentos do método. Para isso funcionar, os argumentos do método devem ser diferentes em pelo menos um
              dos três critérios a seguir:</p>
            <ul class="checklist">
              <li>Os métodos precisam ter um número diferente de argumentos.</li>
              <li>Os métodos devem ter tipos de dados diferentes nos seus argumentos (por exemplo, um método recebendo
                uma <i>string</i> e outro, um <i>date</i>).</li>
              <li>Os métodos devem receber os argumentos em ordens diferentes.</li>
            </ul>
            <p>Nessa estratégia, devido ao diferente conjunto de argumentos, cada método tem uma assinatura diferente.
              Isso permite que o compilador identifique qual método deve ser chamado (de acordo com os argumentos
              providos) e o vincule à chamada do método, sendo determinado o comportamento que será executado ainda no
              compilador.</p>
            <p>Confira o exemplo no código a seguir:</p>
            <pre>
                  <code>
<span style="color: #4073e0">class</span> <span style="color: #00aa00;">Calculadora</span> {
    <span style="color: #00aaaa">int</span> <span style="color: #00aa00">somar</span> (<span style="color: #00aaaa">int</span> a, <span style="color: #00aaaa">int</span> b) {
        <span style="color: #4073e0">return</span> a + b;
    }

    <span style="color: #00aaaa">int</span> <span style="color: #00aa00">somar</span> (<span style="color: #00aaaa">int</span> a, <span style="color: #00aaaa">int</span> b, <span style="color: #00aaaa">int</span> c) {
        <span style="color: #4073e0">return</span> a + b + c;
    }
}
                  </code>
                </pre>
            <p>Nesse exemplo, note que foi criada uma classe <b>Calculadora</b> com o método <b>somar()</b>. Definiu-se
              o método duas vezes, porém com o conjunto de argumentos diferentes.</p>
            <div class="caixa-destaque">
              <p>A primeira versão do método <b>somar()</b> espera receber dois argumentos do tipo <i>int</i> (números
                inteiros), chamados de "a" e "b". Já a segunda versão do método espera receber três argumentos do tipo
                <i>int</i>, chamados de "a", "b" e "c".</p>
            </div>
            <p>Este é um exemplo simples do conceito de sobrecarga de método. Se você instanciar a classe
              <b>Calculadora</b> e executar o método <b>.somar()</b> passando apenas dois números inteiros como
              argumento, o compilador já identificará que está sendo utilizada a primeira versão (que espera receber
              dois argumentos). Agora, se você executar o método <b>.somar()</b> passando três números inteiros como
              argumento, o compilador identificará que está sendo utilizada a segunda versão (que espera receber três
              números inteiros).</p>
            <p>Agora veja este outro exemplo:</p>
            <pre>
                  <code>
<span style="color: #4073e0">class</span> <span style="color: #00aa00;">Usuario</span> {
    <span style="color: #00aaaa">void</span> <span style="color: #00aa00">seguir</span> (Usuario usuario) {
        <span style="color: #aaaaaa; font-style: italic">// Seguir um usuário novo</span>
    }

    <span style="color: #00aaaa">void</span> <span style="color: #00aa00">seguir</span> (Comunidade) {
        <span style="color: #aaaaaa; font-style: italic">// Seguir uma comunidade</span>
    }

    <span style="color: #00aaaa">void</span> <span style="color: #00aa00">seguir</span> (Hashtag) {
        <span style="color: #aaaaaa; font-style: italic">// Seguir uma hashtag</span>
    }
}
                  </code>
                </pre>
            <p>Nesse caso, há um hipotético usuário de rede social, que pode seguir usuários, comunidades e
              <i>hashtags</i>. A sobrecarga de método está sendo feita sobre o método <b>.seguir()</b>, mudando apenas a
              sua assinatura, indicando se é um usuário, uma comunidade ou uma <i>hashtag</i> que está sendo seguida.
              Dessa forma, é possível adotar comportamentos diferentes de acordo com os argumentos providos.</p>
            <div class="caixa-destaque icone desafio">
              <p>Crie um programa orientado a objetos que simule uma autenticação. Aplique sobrecarga de método para
                validar com <i>login</i> e senha ou com número de celular e código numérico. Não se preocupe em validar
                a autenticidade, apenas apresente uma mensagem de sucesso dizendo qual método de autenticação foi usado
                (senha ou código).</p>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Fechar</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal fade" id="modal-polimorfismo02" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                aria-hidden="true">×</span></button>
            <h4 class="modal-title" id="myModalLabel">Polimorfismo dinâmico</h4>
          </div>
          <div class="modal-body">
            <p>Como dito anteriormente, existe outro tipo de polimorfismo, no qual só é possível validar qual
              comportamento/versão será executado em tempo de execução (isto é, executando o código-fonte). Esse formato
              de polimorfismo é conhecido como <b>polimorfismo dinâmico</b>.</p>
            <p>Como ele, o compilador não consegue determinar a versão/comportamento que será executada de um método ou
              classe polimorfa. Nesse cenário, a diferença existe apenas no tempo de execução, ou seja, é um cenário
              muito comum e utilizado em alguns conceitos de boas práticas, que serão estudados futuramente, como na
              injeção de dependências.</p>
            <p>O polimorfismo dinâmico também é conhecido como:</p>
            <ul class="cor01">
              <li>Polimorfismo em tempo de execução (do inglês <i>run-time polymorphism</i>)</li>
              <li>Ligação dinâmica (<i>dynamic binding</i>)</li>
              <li>Ligação em tempo de execução (<i>run-time binding</i>)</li>
              <li>Ligação tardia (<i>late binding</i>)</li>
              <li>Sobreposição de método (<i>method overriding</i>)</li>
            </ul>
            <p>Para o polimorfismo dinâmico funcionar, suponha que existam diferentes métodos com a mesma assinatura
              (isto é, métodos que recebem os mesmos argumentos e retornam o mesmo tipo de dado), sendo cada método em
              uma classe diferente. Para caracterizar o polimorfismo dinâmico, cada classe deverá (1) herdar da mesma
              superclasse ou (2) implementar a mesma interface ou classe abstrata.</p>
            <p>Assim como no polimorfismo estático, existem diversas técnicas para atingir o objetivo do polimorfismo
              dinâmico, dependendo dos recursos providos pela linguagem de programação em uso. No Java, é muito comum a
              utilização da técnica de <b>sobreposição de método</b>. Para exemplificar um cenário, observe a imagem a
              seguir.</p>
            <img src="objetos/layout_5_fig8_ilustra_falas.png" class="img-responsive center-block">
            <p class="legenda-imagem">
              Exemplo de polimorfismo com a ação “Falar” <br>
              Fonte: Adaptado de Ediriweera (2017)
            </p>
            <p class="acessivel no-print">A imagem contém um homem falando "Agora falem!" para um cachorro, um pato e um
              gato. O cachorro está respondendo "Au-au", o pato está respondendo "Quac" e o gato está respondendo
              "Miau".</p>
            <p>Note que todos os objetos são animais e que cada um “fala” de uma maneira específica. Essa imagem é um
              exemplo de sobreposição de método, uma estratégia para alcançar o polimorfismo dinâmico. Nele, estão três
              animais diferentes: um cachorro, um pato e um gato. Os três animais são capazes de se comunicar (no
              programa, esse método é chamado de "falar"), porém cada animal comunica-se de uma forma diferente.</p>
            <p>Que tal trazer esse exemplo da vida real para código? Analise o código a seguir:</p>
            <pre>
                  <code>
<span style="color: #4073e0">class</span> <span style="color: #00aa00;">Animal</span> {   
    <span style="color: #4073e0">public</span> <span style="color: #00aaaa">void</span> <span style="color: #00aa00">falar</span> (){
        System.<span style="color: #a0ceff">out</span>.<span style="color: #a0ceff">println</span>(<span style="color: #aa5500">&quot;???&quot;</span>);
    }
}
                  </code>
                </pre>
            <pre>
                  <code>
<span style="color: #4073e0">class</span> <span style="color: #00aa00;">Cachorro</span> <span style="color: #4073e0">extends</span> Animal {
    <span style="color: #4073e0">public</span> <span style="color: #00aaaa">void</span> <span style="color: #00aa00">falar</span> () {
        System.<span style="color: #a0ceff">out</span>.<span style="color: #a0ceff">println</span>(<span style="color: #aa5500">&quot;Au au&quot;</span>);
    }
}
                  </code>
                </pre>
            <pre>
                  <code>
<span style="color: #4073e0">class</span> <span style="color: #00aa00;">Pato</span> <span style="color: #4073e0">extends</span> Animal {
    <span style="color: #4073e0">public</span> <span style="color: #00aaaa">void</span> <span style="color: #00aa00">falar</span> () {
        System.<span style="color: #a0ceff">out</span>.<span style="color: #a0ceff">println</span>(<span style="color: #aa5500">&quot;Quack&quot;</span>);
    }
}
                  </code>
                </pre>
            <pre>
                  <code>
<span style="color: #4073e0">class</span> <span style="color: #00aa00;">Gato</span> <span style="color: #4073e0">extends</span> Animal {
    <span style="color: #4073e0">public</span> <span style="color: #00aaaa">void</span> <span style="color: #00aa00">falar</span> () {
        System.<span style="color: #a0ceff">out</span>.<span style="color: #a0ceff">println</span>(<span style="color: #aa5500">&quot;Miau&quot;</span>);
    }
}
                  </code>
                </pre>
            <p>Transformando esse exemplo em código, há uma superclasse chamada <b>Animal</b> e três subclasses chamadas
              <b>Cachorro</b>, <b>Pato</b> e <b>Gato</b>. A superclasse e as subclasses tem um método <b>falar</b> com a
              mesma assinatura (sem argumentos de entrada e com o mesmo retorno <i>void</i>), porém cada subclasse
              contém um comportamento específico.</p>
            <p>Agora serão utilizadas as classes:</p>
            <pre>
                  <code>
<span style="color: #4073e0">public</span> <span style="color: #4073e0">class</span> <span style="color: #00aa00;">MeuProjeto</span> {
    <span style="color: #4073e0">public</span> <span style="color: #4073e0">static</span> <span style="color: #00aaaa">void</span> <span style="color: #00aa00">main</span>(String args[]) {
        Animal cachorro = <span style="color: #4073e0">new</span> Cachorro();
        Animal pato = <span style="color: #4073e0">new</span> Pato();
        Animal gato = <span style="color: #4073e0">new</span> Gato();

        cachorro.<span style="color: #a0ceff">falar</span>(); <span style="color: #aaaaaa; font-style: italic">// &quot;Au au&quot;</span>
        pato.<span style="color: #a0ceff">falar</span>(); <span style="color: #aaaaaa; font-style: italic">// &quot;Quack&quot;</span>
        gato.<span style="color: #a0ceff">falar</span>(); <span style="color: #aaaaaa; font-style: italic">// &quot;Miau&quot;</span>
    }
}
                  </code>
                </pre>
            <p>Note que os três objetos são do tipo “Animal”. Isso implica que, caso alguma outra função do programa
              precise receber algum animal, todos os três objetos são argumentos válidos para serem utilizados. Porém,
              cada objeto foi instanciado por meio de uma subclasse diferente. O objeto "cachorro" foi instanciado da
              classe <b>Cachorro</b>, o objeto "pato" foi instanciado da classe <b>Pato</b> e o objeto "gato" foi
              instanciado da classe <b>Gato</b>. Logo, ao chamar o método <b>falar</b> de qualquer um dos animais, você
              terá resultados diferentes em tempo de execução.</p>
            <p>Em outras palavras, em um exemplo de sobreposição de métodos utilizando herança (ou seja, com uma
              superclasse e diversas subclasses), quando um objeto é atribuído a uma classe de referência (ou seja, à
              superclasse) e um de seus métodos é chamado, o método executado será o da classe do objeto (a subclasse) e
              não o da classe de referência (a superclasse). Isso é exatamente o que foi visto no código de exemplo
              anterior. Todos os objetos são do tipo da superclasse (<b>Animal</b>, a classe de referência), mas, quando
              se executa o método <b>falar</b>, é executado o comportamento da subclasse (a classe do objeto).</p>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Fechar</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade" id="modal-painel_robo01" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                aria-hidden="true">×</span></button>
            <h4 class="modal-title" id="myModalLabel">Robô</h4>
          </div>
          <div class="modal-body">
            <img src="objetos/gif_01.gif" class="img-responsive center-block">
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Fechar</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal fade" id="modal-painel_robo02" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                aria-hidden="true">×</span></button>
            <h4 class="modal-title" id="myModalLabel">Robô Cheetah</h4>
          </div>
          <div class="modal-body">
            <img src="objetos/gif_02.gif" class="img-responsive center-block">
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Fechar</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal fade" id="modal-painel_robo03" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                aria-hidden="true">×</span></button>
            <h4 class="modal-title" id="myModalLabel">Robô de limpeza</h4>
          </div>
          <div class="modal-body">
            <img src="objetos/gif_03.gif" class="img-responsive center-block">
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Fechar</button>
          </div>
        </div>
      </div>
    </div>
    


    <!-- Modais 100% -->
    <div class="modal modal-100 fade" id="modal-categoria01" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content no-print">
          <div class="modal-header" style="padding-top: 30px;">
            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
            <h3 class="modal-title">
              <div class="container">Associação</div>
            </h3>
          </div>
          <div class="modal-body">
            <div class="container">
              <p>Agora você já conhece a composição e a agregação e entende que ambas são os tipos mais restritivos de
                associação. Isso significa que os exemplos vistos anteriormente podem ser chamados de associação.
                Criando um conceito geral, é possível afirmar que a associação é a simples relação entre duas classes,
                por meio de seus objetos. Uma associação pode ser um para um, um para muitos, muitos para um ou muitos
                para muitos. Entretanto, existe um tipo de associação que não se enquadra como composição e nem como
                agregação. Trata-se da <b>associação bidirecional</b>.</p>
              <p>Como a agregação e a composição só podem ser unidirecionais, um relacionamento bidirecional é
                exclusivamente uma associação. Para entender melhor, é preciso começar compreendendo as semelhanças.</p>
              <p>Uma associação é, assim como a agregação, um relacionamento semanticamente fraco entre duas classes
                distintas. Ou seja, as duas classes existem sem depender uma da outra. Também como a composição e a
                agregação, uma associação é um relacionamento de "uso" (identificado pelo verbo "ter") entre dois ou
                mais objetos.</p>
              <p>Apesar das semelhanças, uma associação bidirecional não tem uma estrutura de proprietário e
                propriedade, sendo dois objetos completamente independentes. Os objetos que fazem parte do
                relacionamento de associação podem ser criados e destruídos de modo independente, e contêm informações e
                comportamentos de maneira independente também.</p>
              <p>Por exemplo, imagine um namoro. Considere apenas uma classe chamada <b>Pessoa</b>, que tem suas
                características e seus comportamentos funcionando e existindo de maneira independente. Entretanto,
                existe uma propriedade cônjuge que faz referência a um outro objeto da classe <b>Pessoa</b>. Este tipo
                de relacionamento chama-se <b>bidirecional</b>, pois os dois objetos relacionam-se um com o outro, de
                maneira bidirecional. Confira o código a seguir:</p>
              <pre>
                    <code>
<span style="color: #4073e0">public</span> <span style="color: #4073e0">class</span> <span style="color: #00aa00;">Pessoa</span> {
    <span style="color: #4073e0">private</span> String nome;
    <span style="color: #4073e0">private</span> Pessoa conjuge = <span style="color: #4073e0">null</span>;

    Pessoa (String nome) {
        <span style="color: #4073e0">this</span>.<span style="color: #a0ceff">nome</span> = nome;
    }

    <span style="color: #4073e0">public</span> String <span style="color: #00aa00">getNome</span>() {
        <span style="color: #4073e0">return</span> <span style="color: #4073e0">this</span>.<span style="color: #a0ceff">nome</span>;
    }

    <span style="color: #4073e0">public</span> <span style="color: #00aaaa">void</span> <span style="color: #00aa00">namorar</span>(Pessoa pessoa) {
        <span style="color: #4073e0">if</span> (<span style="color: #4073e0">this</span>.<span style="color: #a0ceff">conjuge</span> == <span style="color: #4073e0">null</span>) {
            <span style="color: #4073e0">this</span>.<span style="color: #a0ceff">conjuge</span> = pessoa;
            pessoa.<span style="color: #a0ceff">namorar</span>(<span style="color: #4073e0">this</span>);
        }
    }

    <span style="color: #4073e0">public</span> Pessoa <span style="color: #00aa00">getConjuge</span>() {
        <span style="color: #4073e0">return</span> <span style="color: #4073e0">this</span>.<span style="color: #a0ceff">conjuge</span>;
    }
}
                    </code>
                  </pre>
              <p>Perceba que a classe <b>Pessoa</b> contém uma propriedade "conjuge" do tipo "Pessoa". Assim como no
                exemplo de agregação, existe um método público que permite prover um valor para essa propriedade.
                Trata-se do método <b>namorar()</b>.</p>
              <p>O método <b>namorar()</b> recebe, por argumento, um objeto da classe <b>Pessoa</b>. Esse objeto então é
                referenciado como valor da propriedade "conjuge". Além disso, o método <b>namorar()</b> implementa o
                relacionamento bidirecional, fazendo o objeto enviado como argumento também referenciar de volta. Dessa
                forma, os dois objetos referenciam-se um ao outro, conceituando um relacionamento bidirecional.</p>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="botao borda-primaria-03" data-dismiss="modal">Fechar</button>
          </div>
        </div>
      </div>
    </div>
    


  </div>

  </div>



  <!--  Em caso de footer personalizado utilizar esse elemento e adicionar a classe customizada
    <footer>
    </footer>
	-->
  <!-- carrega todas as imagens dos icones nesta div
 caso queira adicionar mais imagens de novos icones do css,
 ou qualquer imagem que deva ser contabilizada durante a fase
 de loading, referenciar aqui.
 -->
  <div class="ico-div-loader">
    <img src="../template/images/atencao.png">
    <img src="../template/images/bg-content.jpg">
    <img src="../template/images/bg-topo.jpg">
    <img src="../template/images/black-zoom-in-256.png">
    <img src="../template/images/concluindo.png">
    <img src="../template/images/curtir.png">
    <img src="../template/images/desafio.png">
    <img src="../template/images/dica.png">
    <img src="../template/images/doc.png">
    <img src="../template/images/fundamental.png">
    <img src="../template/images/icon-03.png">
    <img src="../template/images/importante.png">
    <img src="../template/images/lightbulb.png">
    <img src="../template/images/link.png">
    <img src="../template/images/link_pdf_hover.png">
    <img src="../template/images/link_pdf_normal.png">
    <img src="../template/images/logo-senac.png">
    <img src="../template/images/mark-icon.png">
    <img src="../template/images/mark-icon02.png">
    <img src="../template/images/midia.png">
    <img src="../template/images/monitor.png">
    <img src="../template/images/nao_curtir.png">
    <img src="../template/images/pergunta.png">
    <img src="../template/images/pesquisa.png">
    <img src="../template/images/play.png">
    <img src="../template/images/radio_flat.png">
    <img src="../template/images/refletir.png">
    <img src="../template/images/saiba_mais.png">
    <img src="../template/images/senac_loader.png">
    <img src="../template/images/tanamidia.png">
    <img src="../template/images/transcricao.png">
    <img src="../template/images/transcricao_small.png">
    <img src="../template/images/tv.png">
    <img src="../template/images/tv_bottom.png">
    <img src="../template/images/zoom.png">
    <img src="../template/images/zoom_ie.cur">
    <img src="../template/images/zoom_ie.png">
    <!-- adicionar as imagens customizadas aqui abaixo -->
  </div>


  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="../template/js/jquery.min.js"></script>
  <script src="../template/js/bootstrap.min.js"></script>
  <script src="../template/js/jquery.magnific-popup.min.js"></script>
  <script src="../template/js/print.js"></script>
  <script src="../template/js/template.config.js"></script>
  <script src="../template/js/images.loader.js"></script>
  <noscript>
    <style media="screen">
      .over-loader {
        display: none;
      }
    </style>
  </noscript>
</body>

</html>
<script>
  //inicializa zoom na imagem
  $('.zoom-imagem').magnificPopup({
    type: 'image',
    mainClass: 'mfp-with-zoom', // this class is for CSS animation below
    zoom: {
      enabled: true, // By default it's false, so don't forget to enable it

      duration: 300, // duration of the effect, in milliseconds
      easing: 'ease-in-out', // CSS transition easing function

      // The "opener" function should return the element from which popup will be zoomed in
      // and to which popup will be scaled down
      // By defailt it looks for an image tag:
      opener: function (openerElement) {
        // openerElement is the element on which popup was initialized, in this case its <a> tag
        // you don't need to add "opener" option if this code matches your needs, it's defailt one.
        return openerElement.is('img') ? openerElement : openerElement.find('img');
      }
    },
    image: {
      markup: '<div class="mfp-figure">' +
        '<div class="mfp-close"></div>' +
        '<div class="mfp-img"></div>' + // Floated left
        '<div class="mfp-bottom-bar">' + '<figcaption>' +
        '<div class="mfp-title" style="text-align:center"></div>' +
        '<div class="mfp-counter"></div>' + '</figcaption>' +
        '</div>' +
        '</div>', // Popup HTML markup. `.mfp-img` div will be replaced with img tag, `.mfp-close` by close button

      cursor: 'mfp-zoom-out-cur', // Class that adds zoom cursor, will be added to body. Set to null to disable zoom out cursor.

      tError: '<a href="%url%">A imagem</a> não pode ser carregada.' // Error message
    }
  });

  //inicializa popover
  $(function () {
    $('[data-toggle="popover"]').popover()
  })
  //inicializa tooltip
  $(function () {
    $('[data-toggle="tooltip"]').tooltip()
  })


  $(function () {
    $(".card").click(function () {
      if ($(this).hasClass("exibe-frente")) {
        $(this)
          .children()
          .first()
          .hide();
        $(this)
          .children()
          .last()
          .show();
        $(this).removeClass("exibe-frente");
      } else {
        $(".card .verso").hide();
        $(".card .frente").show();
        $(this).addClass("exibe-frente");
      }
    });
  });

  $(document).ready(function () {
    $(".card .verso").hide();
  });




  /*------- Script de animação do botão -------*/
  var root = document.documentElement;
  root.className += ' js';

  function boxTop(idBox) {
    var boxOffset = $(idBox).offset().top;
    return boxOffset;
  }

  $(document).ready(function () {
    var $target = $('.animeStart'),
      $target2 = $('.animeStop'),
      targetBox = $('.box'),
      animationClass = 'anime-init',
      windowHeight = $(window).height(),
      offset = windowHeight - (windowHeight / 4);

    function animeScroll() {
      var documentTop = $(document).scrollTop();
      $target.each(function () {
        if (documentTop > boxTop(this) - offset) {
          targetBox.addClass(animationClass);
        } else {
          targetBox.removeClass(animationClass);
        }
        if (documentTop > boxTop($target2) - offset) {
          targetBox.removeClass(animationClass);
        }
      });
    }
    animeScroll();

    $(document).scroll(function () {
      animeScroll();
    });
  });


  $(document).ready(function () {

    //localStorage.clear()

    var pagsTotais;

    //Menu normal
    $('.menu-titulo1').click(function () {
      localStorage.setItem('pagTitulo1', '2');
    });
    $('.menu-titulo2').click(function () {
      localStorage.setItem('pagTitulo2', '3');
    });
    $('.menu-titulo3').click(function () {
      localStorage.setItem('pagTitulo3', '4');
    });
    $('.menu-titulo4').click(function () {
      localStorage.setItem('pagTitulo4', '5');
    });
    $('.menu-titulo5').click(function () {
      localStorage.setItem('pagTitulo5', '6');
    });
    $('.menu-titulo6').click(function () {
      localStorage.setItem('pagTitulo6', '7');
    });
    $('.menu-titulo7').click(function () {
      localStorage.setItem('pagTitulo7', '8');
    });
    $('.menu-titulo8').click(function () {
      localStorage.setItem('pagTitulo8', '9');
    });

    //Menu mobile
    $('#menu-titulo1_mobile').click(function () {
      localStorage.setItem('pagTitulo1', '2');
    });
    $('#menu-titulo2_mobile').click(function () {
      localStorage.setItem('pagTitulo2', '3');
    });
    $('#menu-titulo3_mobile').click(function () {
      localStorage.setItem('pagTitulo3', '4');
    });
    $('#menu-titulo4_mobile').click(function () {
      localStorage.setItem('pagTitulo4', '5');
    });
    $('#menu-titulo5_mobile').click(function () {
      localStorage.setItem('pagTitulo5', '6');
    });
    $('#menu-titulo6_mobile').click(function () {
      localStorage.setItem('pagTitulo6', '7');
    });
    $('#menu-titulo7_mobile').click(function () {
      localStorage.setItem('pagTitulo7', '8');
    });
    $('#menu-titulo8_mobile').click(function () {
      localStorage.setItem('pagTitulo8', '9');
    });

    pagsTotais = localStorage.getItem('pagTitulo1') +
      localStorage.getItem('pagTitulo2') +
      localStorage.getItem('pagTitulo3') +
      localStorage.getItem('pagTitulo4') +
      localStorage.getItem('pagTitulo5') +
      localStorage.getItem('pagTitulo6') +
      localStorage.getItem('pagTitulo7') +
      localStorage.getItem('pagTitulo8');

    //alert('Info: '+pagsTotais);

    if (pagsTotais.includes('2')) {
      $('#menu-titulo1').addClass('pag-visitada');
      $('#menu-titulo1_mobile').addClass('pag-visitada');
    }
    if (pagsTotais.includes('3')) {
      $('#menu-titulo2').addClass('pag-visitada');
      $('#menu-titulo2_mobile').addClass('pag-visitada');
    }
    if (pagsTotais.includes('4')) {
      $('#menu-titulo3').addClass('pag-visitada');
      $('#menu-titulo3_mobile').addClass('pag-visitada');
    }
    if (pagsTotais.includes('5')) {
      $('#menu-titulo4').addClass('pag-visitada');
      $('#menu-titulo4_mobile').addClass('pag-visitada');
    }
    if (pagsTotais.includes('6')) {
      $('#menu-titulo5').addClass('pag-visitada');
      $('#menu-titulo5_mobile').addClass('pag-visitada');
    }
    if (pagsTotais.includes('7')) {
      $('#menu-titulo6').addClass('pag-visitada');
      $('#menu-titulo6_mobile').addClass('pag-visitada');
    }
    if (pagsTotais.includes('8')) {
      $('#menu-titulo7').addClass('pag-visitada');
      $('#menu-titulo7_mobile').addClass('pag-visitada');
    }
    if (pagsTotais.includes('9')) {
      $('#menu-titulo8').addClass('pag-visitada');
      $('#menu-titulo8_mobile').addClass('pag-visitada');
    }

  });
</script>

<!-- Versao atual do handtalk -->
<script>
  var scriptElem = document.createElement("script");
  scriptElem.src = "https://plugin.handtalk.me/web/latest/handtalk.min.js",
    scriptElem.charset = "UTF-8",
    scriptElem.onload = function () {
      window.ht = new HT({
        token: "bf5b7efb148a829a126a0e0c9fd533bf",
        align: "top",
        videoEnabled: true,
        ytEmbedReplace: true,
        mobileConfig: {
          align: "right",
          actionsAlign: "top",
          customButtonStyle: {
            borderRadius: "6px",
            size: "38px",
            horizontalMargin: "13px",
            bottomMargin: "140px",
            rightMargin: "40px"
          }
        }
      });
      $('.ht-skip').attr("aria-hidden", "true")
    },
    document.body.appendChild(scriptElem);
</script>

<script>

  var url = new URL(window.location.href);
  
  var params = new URLSearchParams(url.search);
  
  var pageNumber = parseInt(params.get('page'));
  
  console.log(pageNumber)
  
  if (pageNumber === 1) {
      document.body.classList.add('pagina-1');
  } else {
      document.body.classList.remove('pagina-1');
  }
  
</script>

<!-- botoes associacao -->

<script>
    // Obtém a referência para o elemento de imagem
    var imagemAssociacao = document.getElementById("composicao");

    // Armazena o src da imagem original
    var srcOriginalAssociacao = imagemAssociacao.src;

    console.log(imagemAssociacao)


    // Define a função para trocar a imagem quando o mouse passar por cima
    imagemAssociacao.addEventListener("mouseover", function() {
        imagemAssociacao.src = "./objetos/painelesquema_1.png"; 
        console.log(imagem)
    });

    // Define a função para restaurar a imagem original quando o mouse sair de cima
    imagemAssociacao.addEventListener("mouseout", function() {
        imagemAssociacao.src = srcOriginalAssociacao;
    });
</script>

<script>
    // Obtém a referência para o elemento de imagem
    var imagem = document.getElementById("agregacao");

    // Armazena o src da imagem original
    var srcOriginal = imagem.src;


    // Define a função para trocar a imagem quando o mouse passar por cima
    imagem.addEventListener("mouseover", function() {
        imagem.src = "./objetos/painelesquema_2.png"; // Substitua "imagem2.jpg" pelo caminho da sua segunda imagem
    });

    // Define a função para restaurar a imagem original quando o mouse sair de cima
    imagem.addEventListener("mouseout", function() {
        imagem.src = srcOriginal;
    });
</script>